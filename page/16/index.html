<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/uploads/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/uploads/favicon.ico">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"dunwu.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":true,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>

    <meta name="description" content="钝悟的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Dunwu Blog">
<meta property="og:url" content="https://dunwu.github.io/blog/page/16/index.html">
<meta property="og:site_name" content="Dunwu Blog">
<meta property="og:description" content="钝悟的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钝悟 ◾ Dunwu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://dunwu.github.io/blog/page/16/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/16/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Dunwu Blog</title>
  






  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Dunwu Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大道至简，知易行难</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">258</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">118</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">365</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="钝悟 ◾ Dunwu"
      src="/blog/uploads/avatar.gif">
  <p class="site-author-name" itemprop="name">钝悟 ◾ Dunwu</p>
  <div class="site-description" itemprop="description">钝悟的个人博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">365</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">118</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">258</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dunwu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dunwu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:forbreak@163.com" title="E-Mail → mailto:forbreak@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/dunwu/blog" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/f1f151/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/f1f151/" class="post-title-link" itemprop="url">Mysql 锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-07 07:54:19" itemprop="dateCreated datePublished" datetime="2020-09-07T07:54:19+08:00">2020-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 18:54:25" itemprop="dateModified" datetime="2022-09-23T18:54:25+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">关系型数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql-锁"><a href="#Mysql-锁" class="headerlink" title="Mysql 锁"></a>Mysql 锁</h1><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200716064947.png" alt="img"></p>
<h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><p>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，<strong>乐观锁和悲观锁是并发控制主要采用的技术手段。</strong></p>
<ul>
<li><strong><code>悲观锁</code></strong> - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<ul>
<li>在查询完数据的时候就把事务锁起来，直到提交事务（<code>COMMIT</code>）</li>
<li>实现方式：<strong>使用数据库中的锁机制</strong>。</li>
</ul>
</li>
<li><strong><code>乐观锁</code></strong> - 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<ul>
<li>在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定</li>
<li>实现方式：<strong>使用 version 版本或者时间戳</strong>。</li>
</ul>
</li>
</ul>
<p>【示例】乐观锁示例</p>
<p>商品 goods 表中有一个字段 status，status 为 1 代表商品未被下单，status 为 2 代表商品已经被下单，那么我们对某个商品下单时必须确保该商品 status 为 1。假设商品的 id 为 1。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> (status,status,version) <span class="keyword">from</span> t_goods <span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t_goods</span><br><span class="line"><span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>,version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更详细的乐观锁说可以参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/laoyeye/p/8097684.html">使用 mysql 乐观锁解决并发问题</a></p>
</blockquote>
<h2 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h2><p>从数据库的锁粒度来看，MySQL 中提供了两种封锁粒度：行级锁和表级锁。</p>
<ul>
<li><strong>表级锁（table lock）</strong> - 锁定整张表。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。</li>
<li><strong>行级锁（row lock）</strong> - 锁定指定的行记录。这样其它进程还是可以对同一个表中的其它记录进行操作。</li>
</ul>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。<strong>锁定的数据量越少，锁竞争的发生频率就越小，系统的并发程度就越高</strong>。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此<strong>锁粒度越小，系统开销就越大</strong>。</p>
<p>在选择锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<p>在 <code>InnoDB</code> 中，<strong>行锁是通过给索引上的索引项加锁来实现的</strong>。<strong>如果没有索引，<code>InnoDB</code> 将会通过隐藏的聚簇索引来对记录加锁</strong>。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul>
<li>独享锁（Exclusive），简写为 X 锁，又称写锁。使用方式：<code>SELECT ... FOR UPDATE;</code></li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。使用方式：<code>SELECT ... LOCK IN SHARE MODE;</code></li>
</ul>
<p>写锁和读锁的关系，简言之：<strong>独享锁存在，其他事务就不能做任何操作</strong>。</p>
<p><strong><code>InnoDB</code> 下的行锁、间隙锁、next-key 锁统统属于独享锁</strong>。</p>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p><strong>当存在表级锁和行级锁的情况下，必须先申请意向锁（表级锁，但不是真的加锁），再获取行级锁</strong>。使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p><strong>意向锁是 <code>InnoDB</code> 自动加的，不需要用户干预</strong>。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁规定：</p>
<ul>
<li>IX&#x2F;IS 是表锁；</li>
<li>X&#x2F;S 是行锁。</li>
<li>一个事务在获得某个数据行的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X&#x2F;IX&#x2F;S&#x2F;IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">X</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="center">❌</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
</tbody></table>
<p>解释如下：</p>
<ul>
<li>任意 IS&#x2F;IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p><strong>多版本并发控制（Multi-Version Concurrency Control, MVCC）可以视为行级锁的一个变种。它在很多情况下都避免了加锁操作，因此开销更低</strong>。不仅是 Mysql，包括 Oracle、PostgreSQL 等其他数据库都实现了各自的 MVCC，实现机制没有统一标准。</p>
<p>MVCC 是 <code>InnoDB</code> 存储引擎实现隔离级别的一种具体方式，<strong>用于实现提交读和可重复读这两种隔离级别</strong>。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h3 id="MVCC-思想"><a href="#MVCC-思想" class="headerlink" title="MVCC 思想"></a>MVCC 思想</h3><p>加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的。</p>
<p>MVCC 的思想是：</p>
<ul>
<li><strong>保存数据在某个时间点的快照，写操作（DELETE、INSERT、UPDATE）更新最新的版本快照；而读操作去读旧版本快照，没有互斥关系</strong>。这一点和 <code>CopyOnWrite</code> 类似。</li>
<li>脏读和不可重复读最根本的原因是<strong>事务读取到其它事务未提交的修改</strong>。在事务进行读取操作时，为了解决脏读和不可重复读问题，<strong>MVCC 规定只能读取已经提交的快照</strong>。当然一个事务可以读取自身未提交的快照，这不算是脏读。</li>
</ul>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>InnoDB 的 MVCC 实现是：在每行记录后面保存两个隐藏列，一个列保存行的创建时间，另一个列保存行的过期时间（这里的时间是指系统版本号）。每开始一个新事务，系统版本号会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<ul>
<li>系统版本号 <code>SYS_ID</code>：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 <code>TRX_ID</code> ：事务开始时的系统版本号。</li>
</ul>
<h3 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h3><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 <code>ROLL_PTR</code> 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t(id, x) <span class="keyword">VALUES</span>(<span class="number">1</span>, &quot;a&quot;);</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x<span class="operator">=</span>&quot;b&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> x<span class="operator">=</span>&quot;c&quot; <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 <code>AUTOCOMMIT</code> 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p>
<p><code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 操作会创建一个日志，并将事务版本号 <code>TRX_ID</code> 写入。<code>DELETE</code> 可以看成是一个特殊的 <code>UPDATE</code>，还会额外将 DEL 字段设置为 1。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>MVCC 维护了一个一致性读视图 <code>consistent read view</code> ，主要包含了当前系统<strong>未提交的事务列表</strong> <code>TRX_IDs &#123;TRX_ID_1, TRX_ID_2, ...&#125;</code>，还有该列表的最小值 <code>TRX_ID_MIN</code> 和 <code>TRX_ID_MAX</code>。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200715135809.png" alt="img"></p>
<p>这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
<p>在进行 <code>SELECT</code> 操作时，根据数据行快照的 <code>TRX_ID</code> 与 <code>TRX_ID_MIN</code> 和 <code>TRX_ID_MAX</code> 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li><code>TRX_ID</code> &lt; <code>TRX_ID_MIN</code>，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li>
<li><code>TRX_ID</code> &gt; <code>TRX_ID_MAX</code>，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li>
<li><code>TRX_ID_MIN</code> &lt;&#x3D; <code>TRX_ID</code> &lt;&#x3D; <code>TRX_ID_MAX</code>，需要根据隔离级别再进行判断：<ul>
<li>提交读：如果 <code>TRX_ID</code> 在 <code>TRX_IDs</code> 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p>
<h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><p>快照读</p>
<p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ...;</span><br></pre></td></tr></table></figure>

<p>当前读</p>
<p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>;</span><br><span class="line"><span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">DELETE</span>;</span><br></pre></td></tr></table></figure>

<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。</p>
<ul>
<li><code>Record Lock</code> - <strong>行锁对索引项加锁，若没有索引则使用表锁</strong>。</li>
<li><code>Gap Lock</code> - <strong>对索引项之间的间隙加锁</strong>。锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15：<code>SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</code>。在 MySQL 中，gap lock 默认是开启的，即 <code>innodb_locks_unsafe_for_binlog</code> 参数值是 disable 的，且 MySQL 中默认的是 RR 事务隔离级别。</li>
<li><code>Next-key lock</code> -它是 <code>Record Lock</code> 和 <code>Gap Lock</code> 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间。</li>
</ul>
<p>只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock。在 <code>Select</code>、<code>Update</code> 和 <code>Delete</code> 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 gap lock 或 next-key lock。</p>
<p>MVCC 不能解决幻读问题，<strong>Next-Key 锁就是为了解决幻读问题</strong>。在可重复读（<code>REPEATABLE READ</code>）隔离级别下，使用 <strong>MVCC + Next-Key 锁</strong> 可以解决幻读问题。</p>
<p>索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL 会先锁定该非主键索引，再锁定相关的主键索引。在 <code>UPDATE</code>、<code>DELETE</code> 操作时，MySQL 不仅锁定 <code>WHERE</code> 条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的 <code>next-key lock</code>。</p>
<p>当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，<code>InnoDB</code> 一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/23008813/">《高性能 MySQL》</a></li>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100028001">《Java 性能调优实战》</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">数据库系统原理</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b55b842f265da0f9e589e79">数据库两大神器【索引和锁】</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/laoyeye/p/8097684.html">使用 mysql 乐观锁解决并发问题</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/3288f3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/3288f3/" class="post-title-link" itemprop="url">MongoDB 应用指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-07 07:54:19" itemprop="dateCreated datePublished" datetime="2020-09-07T07:54:19+08:00">2020-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 18:54:25" itemprop="dateModified" datetime="2022-09-23T18:54:25+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">文档数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/" itemprop="url" rel="index"><span itemprop="name">MongoDB</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MongoDB-应用指南"><a href="#MongoDB-应用指南" class="headerlink" title="MongoDB 应用指南"></a>MongoDB 应用指南</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<h3 id="MongoDB-发展"><a href="#MongoDB-发展" class="headerlink" title="MongoDB 发展"></a>MongoDB 发展</h3><ul>
<li>1.x - 支持复制和分片</li>
<li>2.x - 更丰富的数据库功能</li>
<li>3.x - WiredTiger 和周边生态</li>
<li>4.x - 支持分布式事务</li>
</ul>
<h3 id="MongoDB-和-RDBMS"><a href="#MongoDB-和-RDBMS" class="headerlink" title="MongoDB 和 RDBMS"></a>MongoDB 和 RDBMS</h3><table>
<thead>
<tr>
<th>特性</th>
<th>MongoDB</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody><tr>
<td>数据模型</td>
<td>文档模型</td>
<td>关系型</td>
</tr>
<tr>
<td>CRUD 操作</td>
<td>MQL&#x2F;SQL</td>
<td>SQL</td>
</tr>
<tr>
<td>高可用</td>
<td>复制集</td>
<td>集群模式</td>
</tr>
<tr>
<td>扩展性</td>
<td>支持分片</td>
<td>数据分区</td>
</tr>
<tr>
<td>扩繁方式</td>
<td>垂直扩展+水平扩展</td>
<td>垂直扩展</td>
</tr>
<tr>
<td>索引类型</td>
<td>B 树、全文索引、地理位置索引、多键索引、TTL 索引</td>
<td>B 树</td>
</tr>
<tr>
<td>数据容量</td>
<td>没有理论上限</td>
<td>千万、亿</td>
</tr>
</tbody></table>
<h3 id="MongoDB-特性"><a href="#MongoDB-特性" class="headerlink" title="MongoDB 特性"></a>MongoDB 特性</h3><ul>
<li>数据是 JSON 结构<ul>
<li>支持结构化、半结构化数据模型</li>
<li>可以动态响应结构变化</li>
</ul>
</li>
<li>通过副本机制提供高可用</li>
<li>通过分片提供扩容能力</li>
</ul>
<h2 id="MongoDB-概念"><a href="#MongoDB-概念" class="headerlink" title="MongoDB 概念"></a>MongoDB 概念</h2><table>
<thead>
<tr>
<th align="left">SQL 术语&#x2F;概念</th>
<th align="left">MongoDB 术语&#x2F;概念</th>
<th align="left">解释&#x2F;说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">database</td>
<td align="left">database</td>
<td align="left">数据库</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">collection</td>
<td align="left">数据库表&#x2F;集合</td>
</tr>
<tr>
<td align="left">row</td>
<td align="left">document</td>
<td align="left">数据记录行&#x2F;文档</td>
</tr>
<tr>
<td align="left">column</td>
<td align="left">field</td>
<td align="left">数据字段&#x2F;域</td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">index</td>
<td align="left">索引</td>
</tr>
<tr>
<td align="left">table joins</td>
<td align="left"></td>
<td align="left">表连接,MongoDB 不支持</td>
</tr>
<tr>
<td align="left">primary key</td>
<td align="left">primary key</td>
<td align="left">主键,MongoDB 自动将_id 字段设置为主键</td>
</tr>
</tbody></table>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>一个 MongoDB 中可以建立多个数据库。</p>
<p>MongoDB 的默认数据库为”db”，该数据库存储在 data 目录中。</p>
<p>MongoDB 的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p>
<p><strong>“show dbs”</strong> 命令可以显示所有数据的列表。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./mongo</span></span><br><span class="line">MongoDBshell version: 3.0.6</span><br><span class="line">connecting to: test</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">show dbs</span></span><br><span class="line">local  0.078GB</span><br><span class="line">test   0.078GB</span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行 <strong>“db”</strong> 命令可以显示当前数据库对象或集合。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./mongo</span></span><br><span class="line">MongoDBshell version: 3.0.6</span><br><span class="line">connecting to: test</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db</span></span><br><span class="line">test</span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行”use”命令，可以连接到一个指定的数据库。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">use <span class="built_in">local</span></span></span><br><span class="line">switched to db local</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db</span></span><br><span class="line">local</span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure>

<p>数据库也通过名字来标识。数据库名可以是满足以下条件的任意 UTF-8 字符串。</p>
<ul>
<li>不能是空字符串（””)。</li>
<li>不得含有 ‘ ‘（空格)、<code>.</code>、<code>\$</code>、<code>/</code>、<code>\</code>和 <code>\0</code> (空字符)。</li>
<li>应全部小写。</li>
<li>最多 64 字节。</li>
</ul>
<p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p>
<ul>
<li><strong>admin</strong>：从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>
<li><strong>local</strong>：这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>
<li><strong>config</strong>：当 Mongo 用于分片设置时，config 数据库在内部使用，用于保存分片的相关信息。</li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p>
<p>需要注意的是：</p>
<ul>
<li>文档中的键&#x2F;值对是有序的。</li>
<li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li>
<li>MongoDB 区分类型和大小写。</li>
<li>MongoDB 的文档不能有重复的键。</li>
<li>文档的键是字符串。除了少数例外情况，键可以使用任意 UTF-8 字符。</li>
</ul>
<p>文档键命名规范：</p>
<ul>
<li>键不能含有 <code>\0</code> (空字符)。这个字符用来表示键的结尾。</li>
<li><code>.</code> 和 <code>$</code> 有特别的意义，只有在特定环境下才能使用。</li>
<li>以下划线 <code>_</code> 开头的键是保留的(不是严格要求的)。</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。</p>
<p>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p>
<p>合法的集合名：</p>
<ul>
<li>集合名不能是空字符串””。</li>
<li>集合名不能含有 <code>\0</code> 字符（空字符)，这个字符表示集合名的结尾。</li>
<li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li>
<li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现 <code>$</code>。</li>
</ul>
<h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>数据库的信息是存储在集合中。它们使用了系统的命名空间：<code>dbname.system.*</code></p>
<p>在 MongoDB 数据库中名字空间 <code>&lt;dbname&gt;.system.*</code> 是包含多种系统信息的特殊集合(Collection)，如下:</p>
<table>
<thead>
<tr>
<th align="left">集合命名空间</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dbname.system.namespaces</td>
<td align="left">列出所有名字空间。</td>
</tr>
<tr>
<td align="left">dbname.system.indexes</td>
<td align="left">列出所有索引。</td>
</tr>
<tr>
<td align="left">dbname.system.profile</td>
<td align="left">包含数据库概要(profile)信息。</td>
</tr>
<tr>
<td align="left">dbname.system.users</td>
<td align="left">列出所有可访问数据库的用户。</td>
</tr>
<tr>
<td align="left">dbname.local.sources</td>
<td align="left">包含复制对端（slave）的服务器信息和状态。</td>
</tr>
</tbody></table>
<p>对于修改系统集合中的对象有如下限制。</p>
<p>在 <code>system.indexes</code> 插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的 drop index 命令将自动更新相关信息)。<code>system.users</code> 是可修改的。<code>system.profile</code> 是可删除的。</p>
<h2 id="MongoDB-数据类型"><a href="#MongoDB-数据类型" class="headerlink" title="MongoDB 数据类型"></a>MongoDB 数据类型</h2><table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String</td>
<td align="left">字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td>
</tr>
<tr>
<td align="left">Integer</td>
<td align="left">整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">布尔值。用于存储布尔值（真&#x2F;假）。</td>
</tr>
<tr>
<td align="left">Double</td>
<td align="left">双精度浮点值。用于存储浮点值。</td>
</tr>
<tr>
<td align="left">Min&#x2F;Max keys</td>
<td align="left">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td>
</tr>
<tr>
<td align="left">Array</td>
<td align="left">用于将数组或列表或多个值存储为一个键。</td>
</tr>
<tr>
<td align="left">Timestamp</td>
<td align="left">时间戳。记录文档修改或添加的具体时间。</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="left">用于内嵌文档。</td>
</tr>
<tr>
<td align="left">Null</td>
<td align="left">用于创建空值。</td>
</tr>
<tr>
<td align="left">Symbol</td>
<td align="left">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td>
</tr>
<tr>
<td align="left">Object ID</td>
<td align="left">对象 ID。用于创建文档的 ID。</td>
</tr>
<tr>
<td align="left">Binary Data</td>
<td align="left">二进制数据。用于存储二进制数据。</td>
</tr>
<tr>
<td align="left">Code</td>
<td align="left">代码类型。用于在文档中存储 JavaScript 代码。</td>
</tr>
<tr>
<td align="left">Regular expression</td>
<td align="left">正则表达式类型。用于存储正则表达式。</td>
</tr>
</tbody></table>
<h2 id="MongoDB-CRUD"><a href="#MongoDB-CRUD" class="headerlink" title="MongoDB CRUD"></a>MongoDB CRUD</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure>

<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use &lt;database&gt;</span><br></pre></td></tr></table></figure>

<p>如果数据库不存在，则创建数据库，否则切换到指定数据库。</p>
<p>【示例】创建数据库，并插入一条数据</p>
<p>刚创建的数据库 test 并不在数据库的列表中， 要显示它，需要插入一些数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">use <span class="built_in">test</span></span></span><br><span class="line">switched to db test</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; show dbs</span></span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.test.insert(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;mongodb&quot;</span>&#125;)</span></span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">show dbs</span></span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line">test    0.000GB</span><br></pre></td></tr></table></figure>

<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><p>删除当前数据库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure>

<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><h4 id="查看集合"><a href="#查看集合" class="headerlink" title="查看集合"></a>查看集合</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show collections</span><br></pre></td></tr></table></figure>

<h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(name, options)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>name: 要创建的集合名称</li>
<li>options: 可选参数, 指定有关内存大小及索引的选项</li>
</ul>
<p>options 可以是如下参数：</p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">capped</td>
<td align="left">布尔</td>
<td align="left">（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 <strong>当该值为 true 时，必须指定 size 参数。</strong></td>
</tr>
<tr>
<td align="left">autoIndexId</td>
<td align="left">布尔</td>
<td align="left">3.2 之后不再支持该参数。（可选）如为 true，自动在 _id 字段创建索引。默认为 false。</td>
</tr>
<tr>
<td align="left">size</td>
<td align="left">数值</td>
<td align="left">（可选）为固定集合指定一个最大值，即字节数。 <strong>如果 capped 为 true，也需要指定该字段。</strong></td>
</tr>
<tr>
<td align="left">max</td>
<td align="left">数值</td>
<td align="left">（可选）指定固定集合中包含文档的最大数量。</td>
</tr>
</tbody></table>
<p>在插入文档时，MongoDB 首先检查固定集合的 size 字段，然后检查 max 字段。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.createCollection(<span class="string">&quot;collection&quot;</span>)</span></span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">show collections</span></span><br><span class="line">collection</span><br></pre></td></tr></table></figure>

<h4 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.collection.drop()</span></span><br><span class="line">true</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">show collections</span></span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="插入文档操作"><a href="#插入文档操作" class="headerlink" title="插入文档操作"></a>插入文档操作</h3><p>MongoDB 使用 insert() 方法完成插入操作。</p>
<p><strong>语法格式</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插入单条记录</span></span><br><span class="line">db.&lt;集合&gt;.insertOne(&lt;JSON&gt;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">插入多条记录</span></span><br><span class="line">db.&lt;集合&gt;.insertMany([&lt;JSON 1&gt;, &lt;JSON 2&gt;, ..., &lt;JSON N&gt;])</span><br></pre></td></tr></table></figure>

<p>【示例】insertOne</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.color.insertOne(&#123;name: <span class="string">&quot;red&quot;</span>&#125;)</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedId&quot; : ObjectId(&quot;5f533ae4e8f16647950fdf43&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【示例】insertMany</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.color.insertMany([</span></span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;yellow&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;name&quot;: &quot;blue&quot;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line">&#123;</span><br><span class="line">        &quot;acknowledged&quot; : true,</span><br><span class="line">        &quot;insertedIds&quot; : [</span><br><span class="line">                ObjectId(&quot;5f533bcae8f16647950fdf44&quot;),</span><br><span class="line">                ObjectId(&quot;5f533bcae8f16647950fdf45&quot;)</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="查询文档操作"><a href="#查询文档操作" class="headerlink" title="查询文档操作"></a>查询文档操作</h3><p>MongoDB 使用 <code>find()</code> 方法完成查询文档操作。</p>
<p><strong>语法格式</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;集合&gt;.find(&lt;JSON&gt;)</span><br></pre></td></tr></table></figure>

<p>查询条件也是 json 形式，如果不设置查询条件，即为全量查询。</p>
<h4 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h4><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">格式</th>
<th align="left">范例</th>
<th align="left">RDBMS 中的类似语句</th>
</tr>
</thead>
<tbody><tr>
<td align="left">等于</td>
<td align="left"><code>&#123;&lt;key&gt;:&lt;value&gt;</code>}</td>
<td align="left"><code>db.book.find(&#123;&quot;pageCount&quot;: &#123;$eq: 0&#125;&#125;)</code></td>
<td align="left"><code>where pageCount = 0</code></td>
</tr>
<tr>
<td align="left">不等于</td>
<td align="left"><code>&#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125;</code></td>
<td align="left"><code>db.book.find(&#123;&quot;pageCount&quot;: &#123;$ne: 0&#125;&#125;)</code></td>
<td align="left"><code>where likes != 50</code></td>
</tr>
<tr>
<td align="left">大于</td>
<td align="left"><code>&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;</code></td>
<td align="left"><code>db.book.find(&#123;&quot;pageCount&quot;: &#123;$gt: 0&#125;&#125;)</code></td>
<td align="left"><code>where likes &gt; 50</code></td>
</tr>
<tr>
<td align="left"><code>&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;</code></td>
<td align="left"><code>db.book.find(&#123;&quot;pageCount&quot;: &#123;$gt: 0&#125;&#125;)</code></td>
<td align="left"><code>where likes &gt; 50</code></td>
<td align="left">大于或等于</td>
</tr>
<tr>
<td align="left">小于</td>
<td align="left"><code>&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;</code></td>
<td align="left"><code>db.book.find(&#123;&quot;pageCount&quot;: &#123;$lt: 200&#125;&#125;)</code></td>
<td align="left"><code>where likes &lt; 50</code></td>
</tr>
<tr>
<td align="left">小于或等于</td>
<td align="left"><code>&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;</code></td>
<td align="left"><code>db.book.find(&#123;&quot;pageCount&quot;: &#123;$lte: 200&#125;&#125;)</code></td>
<td align="left"><code>where likes &lt;= 50</code></td>
</tr>
</tbody></table>
<blockquote>
<p>说明：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">eq  --------  equal  =</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ne ----------- not equal  !=</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gt -------- greater than  &gt;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gte --------- gt equal  &gt;=</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">lt -------- less than  &lt;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">lte --------- lt equal  &lt;=</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>【示例】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计匹配查询条件的记录数</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.book.find(&#123;<span class="string">&quot;status&quot;</span>: <span class="string">&quot;MEAP&quot;</span>&#125;).count()</span></span><br><span class="line">68</span><br></pre></td></tr></table></figure>

<h4 id="查询逻辑条件"><a href="#查询逻辑条件" class="headerlink" title="查询逻辑条件"></a>查询逻辑条件</h4><p>（1）and 条件</p>
<p>MongoDB 的 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规 SQL 的 AND 条件。</p>
<p>语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()</span></span><br></pre></td></tr></table></figure>

<p>（2）or 条件</p>
<p>MongoDB OR 条件语句使用了关键字 <strong>$or</strong>,语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">db.col.find(</span></span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">).pretty()</span><br></pre></td></tr></table></figure>

<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>查询 title 包含”教”字的文档：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123; title: /教/ &#125;)</span><br></pre></td></tr></table></figure>

<p>查询 title 字段以”教”字开头的文档：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123; title: /^教/ &#125;)</span><br></pre></td></tr></table></figure>

<p>查询 titl e 字段以”教”字结尾的文档：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123; title: /教$/ &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Limit-方法"><a href="#Limit-方法" class="headerlink" title="Limit() 方法"></a>Limit() 方法</h4><p>如果你需要在 MongoDB 中读取指定数量的数据记录，可以使用 MongoDB 的 Limit 方法，limit()方法接受一个数字参数，该参数指定从 MongoDB 中读取的记录条数。</p>
<p>limit()方法基本语法如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">db.COLLECTION_NAME.find().<span class="built_in">limit</span>(NUMBER)</span></span><br></pre></td></tr></table></figure>

<h4 id="Skip-方法"><a href="#Skip-方法" class="headerlink" title="Skip() 方法"></a>Skip() 方法</h4><p>我们除了可以使用 limit()方法来读取指定数量的数据外，还可以使用 skip()方法来跳过指定数量的数据，skip 方法同样接受一个数字参数作为跳过的记录条数。</p>
<p>skip() 方法脚本语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">db.COLLECTION_NAME.find().<span class="built_in">limit</span>(NUMBER).skip(NUMBER)</span></span><br></pre></td></tr></table></figure>

<h4 id="Sort-方法"><a href="#Sort-方法" class="headerlink" title="Sort() 方法"></a>Sort() 方法</h4><p>在 MongoDB 中使用 sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>
<p>sort()方法基本语法如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">db.COLLECTION_NAME.find().<span class="built_in">sort</span>(&#123;KEY:1&#125;)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。</p>
</blockquote>
<h3 id="更新文档操作"><a href="#更新文档操作" class="headerlink" title="更新文档操作"></a>更新文档操作</h3><p>update() 方法用于更新已存在的文档。语法格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li><strong>query</strong> : update 的查询条件，类似 sql update 查询内 where 后面的。</li>
<li><strong>update</strong> : update 的对象和一些更新的操作符（如$,$inc…）等，也可以理解为 sql update 查询内 set 后面的</li>
<li><strong>upsert</strong> : 可选，这个参数的意思是，如果不存在 update 的记录，是否插入 objNew,true 为插入，默认是 false，不插入。</li>
<li><strong>multi</strong> : 可选，mongodb 默认是 false,只更新找到的第一条记录，如果这个参数为 true,就把按条件查出来多条记录全部更新。</li>
<li><strong>writeConcern</strong> :可选，抛出异常的级别。</li>
</ul>
<p>【示例】更新文档</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(&#123; title: &#x27;MongoDB 教程&#x27; &#125;, &#123; $set: &#123; title: &#x27;MongoDB&#x27; &#125; &#125;)</span><br></pre></td></tr></table></figure>

<p>【示例】更新多条相同文档</p>
<p>以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">  &#123; title: &#x27;MongoDB 教程&#x27; &#125;,</span><br><span class="line">  &#123; $set: &#123; title: &#x27;MongoDB&#x27; &#125; &#125;,</span><br><span class="line">  &#123; multi: true &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>【示例】更多实例</p>
<p>只更新第一条记录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(&#123; count: &#123; $gt: 1 &#125; &#125;, &#123; $set: &#123; test2: &#x27;OK&#x27; &#125; &#125;)</span><br></pre></td></tr></table></figure>

<p>全部更新：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">  &#123; count: &#123; $gt: 3 &#125; &#125;,</span><br><span class="line">  &#123; $set: &#123; test2: &#x27;OK&#x27; &#125; &#125;,</span><br><span class="line">  false,</span><br><span class="line">  true</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>只添加第一条：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">  &#123; count: &#123; $gt: 4 &#125; &#125;,</span><br><span class="line">  &#123; $set: &#123; test5: &#x27;OK&#x27; &#125; &#125;,</span><br><span class="line">  true,</span><br><span class="line">  false</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>全部添加进去:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">  &#123; count: &#123; $gt: 4 &#125; &#125;,</span><br><span class="line">  &#123; $set: &#123; test5: &#x27;OK&#x27; &#125; &#125;,</span><br><span class="line">  true,</span><br><span class="line">  false</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>全部更新：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">  &#123; count: &#123; $gt: 4 &#125; &#125;,</span><br><span class="line">  &#123; $set: &#123; test5: &#x27;OK&#x27; &#125; &#125;,</span><br><span class="line">  true,</span><br><span class="line">  false</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>只更新第一条记录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">  &#123; count: &#123; $gt: 4 &#125; &#125;,</span><br><span class="line">  &#123; $set: &#123; test5: &#x27;OK&#x27; &#125; &#125;,</span><br><span class="line">  true,</span><br><span class="line">  false</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="删除文档操作"><a href="#删除文档操作" class="headerlink" title="删除文档操作"></a>删除文档操作</h3><p>官方推荐使用 deleteOne() 和 deleteMany() 方法删除数据。</p>
<p>删除 status 等于 A 的全部文档：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.deleteMany(&#123; status: &#x27;A&#x27; &#125;)</span><br></pre></td></tr></table></figure>

<p>删除 status 等于 D 的一个文档：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.deleteOne(&#123; status: &#x27;D&#x27; &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB 在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p>
<p>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p>
<p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。</p>
<p>MongoDB 使用 createIndex() 方法来创建索引。</p>
<p>createIndex()方法基本语法格式如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">db.collection.createIndex(keys, options)</span></span><br></pre></td></tr></table></figure>

<p>语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">db.col.createIndex(&#123;<span class="string">&quot;title&quot;</span>:1&#125;)</span></span><br></pre></td></tr></table></figure>

<p>createIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">db.col.createIndex(&#123;<span class="string">&quot;title&quot;</span>:1,<span class="string">&quot;description&quot;</span>:-1&#125;)</span></span><br></pre></td></tr></table></figure>

<p>createIndex() 接收可选参数，可选参数列表如下：</p>
<table>
<thead>
<tr>
<th align="left">Parameter</th>
<th align="left">Type</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">background</td>
<td align="left">Boolean</td>
<td align="left">建索引过程会阻塞其它数据库操作，background 可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为<strong>false</strong>。</td>
</tr>
<tr>
<td align="left">unique</td>
<td align="left">Boolean</td>
<td align="left">建立的索引是否唯一。指定为 true 创建唯一索引。默认值为<strong>false</strong>.</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">string</td>
<td align="left">索引的名称。如果未指定，MongoDB 的通过连接索引的字段名和排序顺序生成一个索引名称。</td>
</tr>
<tr>
<td align="left"><del>dropDups</del></td>
<td align="left"><del>Boolean</del></td>
<td align="left"><del><strong>3.0+版本已废弃。</strong>在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 <strong>false</strong>。</del></td>
</tr>
<tr>
<td align="left">sparse</td>
<td align="left">Boolean</td>
<td align="left">对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为 true 的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 <strong>false</strong>.</td>
</tr>
<tr>
<td align="left">expireAfterSeconds</td>
<td align="left">integer</td>
<td align="left">指定一个以秒为单位的数值，完成 TTL 设定，设定集合的生存时间。</td>
</tr>
<tr>
<td align="left">v</td>
<td align="left">index version</td>
<td align="left">索引的版本号。默认的索引版本取决于 mongod 创建索引时运行的版本。</td>
</tr>
<tr>
<td align="left">weights</td>
<td align="left">document</td>
<td align="left">索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td>
</tr>
<tr>
<td align="left">default_language</td>
<td align="left">string</td>
<td align="left">对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>
</tr>
<tr>
<td align="left">language_override</td>
<td align="left">string</td>
<td align="left">对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的 language，默认值为 language.</td>
</tr>
</tbody></table>
<h2 id="MongoDB-聚合操作"><a href="#MongoDB-聚合操作" class="headerlink" title="MongoDB 聚合操作"></a>MongoDB 聚合操作</h2><p>MongoDB 中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似 sql 语句中的 count(*)。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>整个聚合运算过程称为管道，它是由多个步骤组成，每个管道</p>
<ul>
<li>接受一系列文档（原始数据）；</li>
<li>每个步骤对这些文档进行一系列运算；</li>
<li>结果文档输出给下一个步骤；</li>
</ul>
<p>聚合操作的基本格式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipeline = [$stage1, $stage1, ..., $stageN];</span><br><span class="line"></span><br><span class="line">db.&lt;集合&gt;.aggregate(pipeline, &#123;options&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="聚合步骤"><a href="#聚合步骤" class="headerlink" title="聚合步骤"></a>聚合步骤</h3><table>
<thead>
<tr>
<th>步骤</th>
<th>作用</th>
<th>SQL 等价运算符</th>
</tr>
</thead>
<tbody><tr>
<td><code>$match</code></td>
<td>过滤</td>
<td>WHERE</td>
</tr>
<tr>
<td><code>$project</code></td>
<td>投影</td>
<td>AS</td>
</tr>
<tr>
<td><code>$sort</code></td>
<td>排序</td>
<td>ORDER BY</td>
</tr>
<tr>
<td><code>$group</code></td>
<td>分组</td>
<td>GROUP BY</td>
</tr>
<tr>
<td><code>$skip</code> &#x2F; <code>$limit</code></td>
<td>结果限制</td>
<td>SKIP &#x2F; LIMIT</td>
</tr>
<tr>
<td><code>$lookup</code></td>
<td>左外连接</td>
<td>LEFT OUTER JOIN</td>
</tr>
<tr>
<td><code>$unwind</code></td>
<td>展开数组</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td><code>$graphLookup</code></td>
<td>图搜索</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td><code>$facet</code> &#x2F; <code>$bucket</code></td>
<td>分面搜索</td>
<td>N&#x2F;A</td>
</tr>
</tbody></table>
<p>【示例】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.collection.insertMany([&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;MongoDB Overview&quot;</span>,<span class="string">&quot;description&quot;</span>:<span class="string">&quot;MongoDB is no sql database&quot;</span>,<span class="string">&quot;by_user&quot;</span>:<span class="string">&quot;collection&quot;</span>,<span class="string">&quot;tagsr&quot;</span>:[<span class="string">&quot;mongodb&quot;</span>,<span class="string">&quot;database&quot;</span>,<span class="string">&quot;NoSQL&quot;</span>],<span class="string">&quot;likes&quot;</span>:<span class="string">&quot;100&quot;</span>&#125;,&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;NoSQL Overview&quot;</span>,<span class="string">&quot;description&quot;</span>:<span class="string">&quot;No sql database is very fast&quot;</span>,<span class="string">&quot;by_user&quot;</span>:<span class="string">&quot;collection&quot;</span>,<span class="string">&quot;tagsr&quot;</span>:[<span class="string">&quot;mongodb&quot;</span>,<span class="string">&quot;database&quot;</span>,<span class="string">&quot;NoSQL&quot;</span>],<span class="string">&quot;likes&quot;</span>:<span class="string">&quot;10&quot;</span>&#125;,&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;Neo4j Overview&quot;</span>,<span class="string">&quot;description&quot;</span>:<span class="string">&quot;Neo4j is no sql database&quot;</span>,<span class="string">&quot;by_user&quot;</span>:<span class="string">&quot;Neo4j&quot;</span>,<span class="string">&quot;tagsr&quot;</span>:[<span class="string">&quot;neo4j&quot;</span>,<span class="string">&quot;database&quot;</span>,<span class="string">&quot;NoSQL&quot;</span>],<span class="string">&quot;likes&quot;</span>:<span class="string">&quot;750&quot;</span>&#125;])</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.collection.aggregate([&#123;<span class="variable">$group</span> : &#123;_id : <span class="string">&quot;<span class="variable">$by_user</span>&quot;</span>, num_tutorial : &#123;<span class="variable">$sum</span> : 1&#125;&#125;&#125;])</span></span><br><span class="line">&#123; &quot;_id&quot; : null, &quot;num_tutorial&quot; : 3 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;Neo4j&quot;, &quot;num_tutorial&quot; : 1 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;collection&quot;, &quot;num_tutorial&quot; : 2 &#125;</span><br></pre></td></tr></table></figure>

<p>下表展示了一些聚合的表达式:</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">描述</th>
<th align="left">实例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>$sum</code></td>
<td align="left">计算总和。</td>
<td align="left"><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : &quot;$likes&quot;&#125;&#125;&#125;])</code></td>
</tr>
<tr>
<td align="left"><code>$avg</code></td>
<td align="left">计算平均值</td>
<td align="left"><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$avg : &quot;$likes&quot;&#125;&#125;&#125;])</code></td>
</tr>
<tr>
<td align="left"><code>$min</code></td>
<td align="left">获取集合中所有文档对应值得最小值。</td>
<td align="left"><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$min : &quot;$likes&quot;&#125;&#125;&#125;])</code></td>
</tr>
<tr>
<td align="left"><code>$max</code></td>
<td align="left">获取集合中所有文档对应值得最大值。</td>
<td align="left"><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$max : &quot;$likes&quot;&#125;&#125;&#125;])</code></td>
</tr>
<tr>
<td align="left"><code>$push</code></td>
<td align="left">在结果文档中插入值到一个数组中。</td>
<td align="left"><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$push: &quot;$url&quot;&#125;&#125;&#125;])</code></td>
</tr>
<tr>
<td align="left"><code>$addToSet</code></td>
<td align="left">在结果文档中插入值到一个数组中，但不创建副本。</td>
<td align="left"><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$addToSet : &quot;$url&quot;&#125;&#125;&#125;])</code></td>
</tr>
<tr>
<td align="left"><code>$first</code></td>
<td align="left">根据资源文档的排序获取第一个文档数据。</td>
<td align="left"><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, first_url : &#123;$first : &quot;$url&quot;&#125;&#125;&#125;])</code></td>
</tr>
<tr>
<td align="left"><code>$last</code></td>
<td align="left">根据资源文档的排序获取最后一个文档数据</td>
<td align="left"><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, last_url : &#123;$last : &quot;$url&quot;&#125;&#125;&#125;])</code></td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.mongodb.com/">MongoDB 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mongodb/mongo">MongoDB Github</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB 教程</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/e98894/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/e98894/" class="post-title-link" itemprop="url">JavaWeb 之 Servlet 指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-24 19:41:46" itemprop="dateCreated datePublished" datetime="2020-08-24T19:41:46+08:00">2020-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 18:54:25" itemprop="dateModified" datetime="2022-09-23T18:54:25+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaEE/JavaWeb/" itemprop="url" rel="index"><span itemprop="name">JavaWeb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JavaWeb-之-Servlet-指南"><a href="#JavaWeb-之-Servlet-指南" class="headerlink" title="JavaWeb 之 Servlet 指南"></a>JavaWeb 之 Servlet 指南</h1><h2 id="JavaWeb-简介"><a href="#JavaWeb-简介" class="headerlink" title="JavaWeb 简介"></a>JavaWeb 简介</h2><h3 id="Web-应用程序"><a href="#Web-应用程序" class="headerlink" title="Web 应用程序"></a>Web 应用程序</h3><p>Web，在英语中 web 即表示网页的意思，它用于表示 Internet 主机上供外界访问的资源。</p>
<p>Web 应用程序是一种可以通过 Web 访问的应用程序，程序的最大好处是用户很容易访问应用程序，用户只需要有浏览器即可，不需要再安装其他软件。</p>
<p>Internet 上供外界访问的 Web 资源分为：</p>
<ul>
<li>静态 web 资源：指 web 页面中供人们浏览的数据始终是不变。常见静态资源文件：html、css、各种图片类型（jpg、png）</li>
<li>动态 web 资源：指 web 页面中供人们浏览的数据是由程序产生的，不同时间点访问 web 页面看到的内容各不相同。常见动态资源技术：JSP&#x2F;Servlet、ASP、PHP</li>
</ul>
<h3 id="常见-Web-服务器"><a href="#常见-Web-服务器" class="headerlink" title="常见 Web 服务器"></a>常见 Web 服务器</h3><ul>
<li><a target="_blank" rel="noopener" href="http://tomcat.apache.org/">Tomcat</a></li>
<li><a target="_blank" rel="noopener" href="http://www.eclipse.org/jetty/">Jetty</a></li>
<li><a target="_blank" rel="noopener" href="https://caucho.com/">Resin</a></li>
<li><a target="_blank" rel="noopener" href="http://httpd.apache.org/">Apache</a></li>
<li><a target="_blank" rel="noopener" href="http://nginx.org/en/">Nginx</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/cloud/websphere-application-platform">WebSphere</a></li>
<li><a target="_blank" rel="noopener" href="https://www.oracle.com/middleware/technologies/weblogic.html">WebLogic</a></li>
<li>JBoss</li>
</ul>
<h2 id="Servlet-简介"><a href="#Servlet-简介" class="headerlink" title="Servlet 简介"></a>Servlet 简介</h2><h3 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet"></a>什么是 Servlet</h3><p>Servlet（Server Applet），即小服务程序或服务连接器。Servlet 是 Java 编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态 Web 内容。</p>
<ul>
<li>狭义的 Servlet 是指 Java 实现的一个接口。</li>
<li>广义的 Servlet 是指任何实现了这个 Servlet 接口的类。</li>
</ul>
<p>Servlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。</p>
<h3 id="Servlet-和-CGI-的区别"><a href="#Servlet-和-CGI-的区别" class="headerlink" title="Servlet 和 CGI 的区别"></a>Servlet 和 CGI 的区别</h3><p>Servlet 技术出现之前，Web 主要使用 CGI 技术。它们的区别如下：</p>
<ul>
<li>Servlet 是基于 Java 编写的，处于服务器进程中，他能够通过多线程方式运行 service() 方法，一个实例可以服务于多个请求，而且一般不会销毁；</li>
<li>CGI(Common Gateway Interface)，即通用网关接口。它会为每个请求产生新的进程，服务完成后销毁，所以效率上低于 Servlet。</li>
</ul>
<h3 id="Servlet-版本以及主要特性"><a href="#Servlet-版本以及主要特性" class="headerlink" title="Servlet 版本以及主要特性"></a>Servlet 版本以及主要特性</h3><table>
<thead>
<tr>
<th>版本</th>
<th>日期</th>
<th>JAVA EE&#x2F;JDK 版本</th>
<th>特性</th>
</tr>
</thead>
<tbody><tr>
<td>Servlet 4.0</td>
<td>2017 年 10 月</td>
<td>JavaEE 8</td>
<td>HTTP2</td>
</tr>
<tr>
<td>Servlet 3.1</td>
<td>2013 年 5 月</td>
<td>JavaEE 7</td>
<td>非阻塞 I&#x2F;O，HTTP 协议升级机制</td>
</tr>
<tr>
<td>Servlet 3.0</td>
<td>2009 年 12 月</td>
<td>JavaEE 6, JavaSE 6</td>
<td>可插拔性，易于开发，异步 Servlet，安全性，文件上传</td>
</tr>
<tr>
<td>Servlet 2.5</td>
<td>2005 年 10 月</td>
<td>JavaEE 5, JavaSE 5</td>
<td>依赖 JavaSE 5，支持注解</td>
</tr>
<tr>
<td>Servlet 2.4</td>
<td>2003 年 11 月</td>
<td>J2EE 1.4, J2SE 1.3</td>
<td>web.xml 使用 XML Schema</td>
</tr>
<tr>
<td>Servlet 2.3</td>
<td>2001 年 8 月</td>
<td>J2EE 1.3, J2SE 1.2</td>
<td>Filter</td>
</tr>
<tr>
<td>Servlet 2.2</td>
<td>1999 年 8 月</td>
<td>J2EE 1.2, J2SE 1.2</td>
<td>成为 J2EE 标准</td>
</tr>
<tr>
<td>Servlet 2.1</td>
<td>1998 年 11 月</td>
<td>未指定</td>
<td>First official specification, added RequestDispatcher, ServletContext</td>
</tr>
<tr>
<td>Servlet 2.0</td>
<td></td>
<td>JDK 1.1</td>
<td>Part of Java Servlet Development Kit 2.0</td>
</tr>
<tr>
<td>Servlet 1.0</td>
<td>1997 年 6 月</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Servlet-任务"><a href="#Servlet-任务" class="headerlink" title="Servlet 任务"></a>Servlet 任务</h3><p>Servlet 执行以下主要任务：</p>
<ul>
<li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li>
<li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li>
<li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li>
<li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li>
<li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li>
</ul>
<h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h3><p><img src="http://www.runoob.com/wp-content/uploads/2014/07/Servlet-LifeCycle.jpg" alt="img"></p>
<p>Servlet 生命周期如下：</p>
<ol>
<li><strong>加载</strong> - 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。容器通过类加载器使用 Servlet 类对应的文件加载 servlet；</li>
<li><strong>初始化</strong> - Servlet 通过调用 <strong>init ()</strong> 方法进行初始化。</li>
<li><strong>服务</strong> - Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li>
<li><strong>销毁</strong> - Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）。</li>
<li><strong>卸载</strong> - Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li>
</ol>
<h2 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h2><h3 id="Servlet-包"><a href="#Servlet-包" class="headerlink" title="Servlet 包"></a>Servlet 包</h3><p>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。</p>
<p>Servlet 可以使用 <strong>javax.servlet</strong> 和 <strong>javax.servlet.http</strong> 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。</p>
<p>Java Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。</p>
<h3 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h3><p>Servlet 接口定义了下面五个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line">    ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="init-方法"><a href="#init-方法" class="headerlink" title="init() 方法"></a>init() 方法</h4><p>init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。</p>
<p>Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。</p>
<p>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。</p>
<p>init 方法的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">  <span class="comment">// 初始化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="service-方法"><a href="#service-方法" class="headerlink" title="service() 方法"></a>service() 方法</h4><p><strong><code>service()</code> 方法是执行实际任务的核心方法</strong>。Servlet 容器（即 Web 服务器）调用 <code>service()</code> 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。</p>
<p><code>service()</code> 方法有两个参数：<code>ServletRequest</code> 和 <code>ServletResponse</code>。<code>ServletRequest</code> 用来封装请求信息，<code>ServletResponse</code> 用来封装响应信息，因此<strong>本质上这两个类是对通信协议的封装。</strong></p>
<p>每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。<code>service()</code> 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 <code>doGet</code>、<code>doPost</code>、<code>doPut</code>，<code>doDelete</code> 等方法。</p>
<p>下面是该方法的特征：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest request,</span></span><br><span class="line"><span class="params">                    ServletResponse response)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException, IOException&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。</p>
<p>doGet() 和 doPost() 方法是每次服务请求中最常用的方法。下面是这两种方法的特征。</p>
<h4 id="doGet-方法"><a href="#doGet-方法" class="headerlink" title="doGet() 方法"></a>doGet() 方法</h4><p>GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                  HttpServletResponse response)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doPost-方法"><a href="#doPost-方法" class="headerlink" title="doPost() 方法"></a>doPost() 方法</h4><p>POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                   HttpServletResponse response)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">// Servlet 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="destroy-方法"><a href="#destroy-方法" class="headerlink" title="destroy() 方法"></a>destroy() 方法</h4><p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。</p>
<p>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。destroy 方法定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 终止化代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Servlet-和-HTTP-状态码"><a href="#Servlet-和-HTTP-状态码" class="headerlink" title="Servlet 和 HTTP 状态码"></a>Servlet 和 HTTP 状态码</h2><p>title: JavaEE Servlet HTTP 状态码<br>date: 2017-11-08<br>categories:</p>
<ul>
<li>javaee<br>tags:</li>
<li>javaee</li>
<li>servlet</li>
<li>http</li>
</ul>
<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>HTTP 请求和 HTTP 响应消息的格式是类似的，结构如下：</p>
<ul>
<li>初始状态行 + 回车换行符（回车+换行）</li>
<li>零个或多个标题行+回车换行符</li>
<li>一个空白行，即回车换行符</li>
<li>一个可选的消息主体，比如文件、查询数据或查询输出</li>
</ul>
<p>例如，服务器的响应头如下所示：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Header2</span><span class="punctuation">: </span>...</span><br><span class="line">...</span><br><span class="line"><span class="attribute">HeaderN</span><span class="punctuation">: </span>...</span><br><span class="line">  (Blank Line)</span><br><span class="line">&lt;!doctype ...&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;...&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>状态行包括 HTTP 版本（在本例中为 HTTP&#x2F;1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）。</p>
<p>以下是可能从 Web 服务器返回的 HTTP 状态码和相关的信息列表：</p>
<ul>
<li><code>1**</code>：信息性状态码</li>
<li><code>2**</code>：成功状态码<ul>
<li>200：请求正常成功</li>
<li>204：指示请求成功但没有返回新信息</li>
<li>206：指示服务器已完成对资源的部分 GET 请求</li>
</ul>
</li>
<li><code>3**</code>：重定向状态码<ul>
<li>301：永久性重定向</li>
<li>302：临时性重定向</li>
<li>304：服务器端允许请求访问资源，但未满足条件</li>
</ul>
</li>
<li><code>4**</code>：客户端错误状态码<ul>
<li>400：请求报文中存在语法错误</li>
<li>401：发送的请求需要有通过 HTTP 认证的认证信息</li>
<li>403：对请求资源的访问被服务器拒绝了</li>
<li>404：服务器上无法找到请求的资源</li>
</ul>
</li>
<li><code>5**</code>：服务器错误状态码<ul>
<li>500：服务器端在执行请求时发生了错误</li>
<li>503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
</ul>
</li>
</ul>
<h3 id="设置-HTTP-状态码的方法"><a href="#设置-HTTP-状态码的方法" class="headerlink" title="设置 HTTP 状态码的方法"></a>设置 HTTP 状态码的方法</h3><p>下面的方法可用于在 Servlet 程序中设置 HTTP 状态码。这些方法通过 <code>HttpServletResponse</code> 对象可用。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>**public void setStatus ( int statusCode )**该方法设置一个任意的状态码。setStatus 方法接受一个 int（状态码）作为参数。如果您的反应包含了一个特殊的状态码和文档，请确保在使用 <em>PrintWriter</em> 实际返回任何内容之前调用 setStatus。</td>
</tr>
<tr>
<td>2</td>
<td>**public void sendRedirect(String url)**该方法生成一个 302 响应，连同一个带有新文档 URL 的 <em>Location</em> 头。</td>
</tr>
<tr>
<td>3</td>
<td>**public void sendError(int code, String message)**该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。</td>
</tr>
</tbody></table>
<h3 id="HTTP-状态码实例"><a href="#HTTP-状态码实例" class="headerlink" title="HTTP 状态码实例"></a>HTTP 状态码实例</h3><p>下面的例子把 407 错误代码发送到客户端浏览器，浏览器会显示 “Need authentication!!!” 消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入必需的 java 库</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展 HttpServlet 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">showError</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 GET 方法请求的方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                    HttpServletResponse response)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 设置错误代码和原因</span></span><br><span class="line">      response.sendError(<span class="number">407</span>, <span class="string">&quot;Need authentication!!!&quot;</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理 POST 方法请求的方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                     HttpServletResponse response)</span></span><br><span class="line">      <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">     doGet(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，调用上面的 Servlet 将显示以下结果：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP Status 407 - Need authentication!!!</span><br><span class="line">type Status report</span><br><span class="line">message Need authentication!!!</span><br><span class="line">description The client must first authenticate itself with the proxy (Need authentication!!!).</span><br><span class="line">Apache Tomcat/5.5.29</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4189495/">Java Web 整合开发王者归来</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/82df5f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/82df5f/" class="post-title-link" itemprop="url">JavaWeb 之 Filter 和 Listener</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-24 19:41:46" itemprop="dateCreated datePublished" datetime="2020-08-24T19:41:46+08:00">2020-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 18:54:25" itemprop="dateModified" datetime="2022-09-23T18:54:25+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaEE/JavaWeb/" itemprop="url" rel="index"><span itemprop="name">JavaWeb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JavaWeb-之-Filter-和-Listener"><a href="#JavaWeb-之-Filter-和-Listener" class="headerlink" title="JavaWeb 之 Filter 和 Listener"></a>JavaWeb 之 Filter 和 Listener</h1><p>引入了 Servlet 规范后，你不需要关心 Socket 网络通信、不需要关心 HTTP 协议，也不需要关心你的业务类是如何被实例化和调用的，因为这些都被 Servlet 规范标准化了，你只要关心怎么实现的你的业务逻辑。这对于程序员来说是件好事，但也有不方便的一面。所谓规范就是说大家都要遵守，就会千篇一律，但是如果这个规范不能满足你的业务的个性化需求，就有问题了，因此设计一个规范或者一个中间件，要充分考虑到可扩展性。Servlet 规范提供了两种扩展机制：<strong>Filter</strong>和<strong>Listener</strong>。</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p><strong>Filter 是过滤器，这个接口允许你对请求和响应做一些统一的定制化处理</strong>。</p>
<p>Filter 提供了过滤链（Filter Chain）的概念，一个过滤链包括多个 Filter。客户端请求 request 在抵达 Servlet 之前会经过过滤链的所有 Filter，服务器响应 response 从 Servlet 抵达客户端浏览器之前也会经过过滤链的所有 FIlter。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/1559054413341.png" alt="img"></p>
<h3 id="过滤器方法"><a href="#过滤器方法" class="headerlink" title="过滤器方法"></a>过滤器方法</h3><p>Filter 接口有三个方法：</p>
<ul>
<li><code>init</code>：初始化 <code>Filter</code></li>
<li><code>destroy</code>：销毁 <code>Filter</code></li>
<li><code>doFilter</code>：将请求传给下个 <code>Filter</code> 或 <code>Servlet</code></li>
</ul>
<p><code>init</code> 和 <code>destroy</code> 方法只会被调用一次；<code>doFilter</code> 每次有客户端请求都会被调用一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * web 程序启动时调用此方法, 用于初始化该 Filter</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment">	 *            可以从该参数中获取初始化参数以及ServletContext信息等</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 客户请求服务器时会经过</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">	 *            客户请求</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">	 *            服务器响应</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> chain</span></span><br><span class="line"><span class="comment">	 *            过滤链, 通过 chain.doFilter(request, response) 将请求传给下个 Filter 或</span></span><br><span class="line"><span class="comment">	 *            Servlet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">			FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * web 程序关闭时调用此方法, 用于销毁一些资源</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤器配置"><a href="#过滤器配置" class="headerlink" title="过滤器配置"></a>过滤器配置</h3><p><code>Filter</code> 需要配置在 <code>web.xml</code> 中才能生效。一个 <code>Filter</code> 需要配置 <code>&lt;filter&gt;</code> 与 <code>&lt;filter-mapping&gt;</code> 标签。</p>
<ul>
<li><code>&lt;filter&gt;</code> 配置 Filter 名称，实现类以及初始化参数。</li>
<li><code>&lt;filter-mapping&gt;</code> 配置什么规则下使用该 Filter。</li>
<li><code>&lt;filter&gt;</code> 的 filterName 与 <code>&lt;filter-mapping&gt;</code> 的 filterName 必须匹配。</li>
<li><code>&lt;url-pattern&gt;</code> 配置 URL 的规则，可以配置多个，可以使用通配符（<code>*</code>）。</li>
<li><code>&lt;dispatcher&gt;</code> 配置到达 Servlet 的方式，有 4 种取值：REQUEST、FORWARD、INCLUDE、ERROR。可以同时配置多个 <code>&lt;dispatcher&gt;</code>。如果没有配置任何 <code>&lt;dispatcher&gt;</code>，默认为 REQUEST。<ul>
<li>REQUEST - 表示仅当直接请求 Servlet 时才生效。</li>
<li>FORWARD - 表示仅当某 Servlet 通过 FORWARD 到该 Servlet 时才生效。</li>
<li>INCLUDE - JSP 中可以通过 <code>&lt;jsp:include&gt;</code> 请求某 Servlet。仅在这种情况表有效。</li>
<li>ERROR - JSP 中可以通过 <code>&lt;%@ page errorPage=&quot;error.jsp&quot; %&gt;</code> 指定错误处理页面。仅在这种情况表有效。</li>
</ul>
</li>
</ul>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>监听器（<code>Listener</code>）用于监听 web 应用程序中的<code>ServletContext</code>, <code>HttpSession</code>和 <code>ServletRequest</code>等域对象的创建与销毁事件，以及监听这些域对象中的属性发生修改的事件。</p>
<p>使用 <code>Listener</code> 不需要关注该类事件时怎样触发或者怎么调用相应的 <code>Listener</code>，只要记住该类事件触发时一定会调用相应的 <code>Listener</code>，遵循 Servlet 规范的服务器会自动完成相应工作。</p>
<h3 id="监听器的分类"><a href="#监听器的分类" class="headerlink" title="监听器的分类"></a>监听器的分类</h3><p>在 Servlet 规范中定义了多种类型的监听器，它们用于监听的事件源分别为<code>ServletContext</code>，<code>HttpSession</code>和<code>ServletRequest</code>这三个域对象<br>Servlet 规范针对这三个对象上的操作，又把多种类型的监听器划分为三种类型：</p>
<ol>
<li>监听域对象自身的创建和销毁的事件监听器。</li>
<li>监听域对象中的属性的增加和删除的事件监听器。</li>
<li>监听绑定到 HttpSession 域中的某个对象的状态的事件监听器。</li>
</ol>
<h3 id="监听对象的创建和销毁"><a href="#监听对象的创建和销毁" class="headerlink" title="监听对象的创建和销毁"></a>监听对象的创建和销毁</h3><h4 id="HttpSessionListener"><a href="#HttpSessionListener" class="headerlink" title="HttpSessionListener"></a>HttpSessionListener</h4><p><strong><code>HttpSessionListener</code> 接口用于监听 <code>HttpSession</code> 对象的创建和销毁。</strong></p>
<ul>
<li>创建一个 <code>Session</code> 时，激发 <code>sessionCreated (HttpSessionEvent se)</code> 方法</li>
<li>销毁一个 <code>Session</code> 时，激发 <code>sessionDestroyed (HttpSessionEvent se)</code> 方法。</li>
</ul>
<h4 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h4><p><strong><code>ServletContextListener</code> 接口用于监听 <code>ServletContext</code> 对象的创建和销毁事件。</strong></p>
<p>实现了 <code>ServletContextListener</code> 接口的类都可以对 <code>ServletContext</code> 对象的创建和销毁进行监听。</p>
<ul>
<li>当 <code>ServletContext</code> 对象被创建时，激发 <code>contextInitialized (ServletContextEvent sce)</code> 方法。</li>
<li>当 <code>ServletContext</code> 对象被销毁时，激发 <code>contextDestroyed(ServletContextEvent sce)</code> 方法。</li>
</ul>
<p><code>ServletContext</code> 域对象创建和销毁时机：</p>
<ul>
<li>创建：服务器启动针对每一个 Web 应用创建 <code>ServletContext</code></li>
<li>销毁：服务器关闭前先关闭代表每一个 web 应用的 <code>ServletContext</code></li>
</ul>
<h4 id="ServletRequestListener"><a href="#ServletRequestListener" class="headerlink" title="ServletRequestListener"></a>ServletRequestListener</h4><p><strong><code>ServletRequestListener</code> 接口用于监听 <code>ServletRequest</code> 对象的创建和销毁。</strong></p>
<ul>
<li><code>Request</code> 对象被创建时，监听器的 <code>requestInitialized(ServletRequestEvent sre)</code> 方法将会被调用</li>
<li><code>Request</code> 对象被销毁时，监听器的 <code>requestDestroyed(ServletRequestEvent sre)</code> 方法将会被调用</li>
</ul>
<p><code>ServletRequest</code> 域对象创建和销毁时机：</p>
<ul>
<li>创建：用户每一次访问都会创建 request 对象</li>
<li>销毁：当前访问结束，request 对象就会销毁</li>
</ul>
<h3 id="监听对象的属性变化"><a href="#监听对象的属性变化" class="headerlink" title="监听对象的属性变化"></a>监听对象的属性变化</h3><p>域对象中属性的变更的事件监听器就是用来监听 <code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code> 这三个对象中的属性变更信息事件的监听器。<br>这三个监听器接口分别是 <code>ServletContextAttributeListener</code>、<code>HttpSessionAttributeListener</code> <code>和 ServletRequestAttributeListener</code>，这三个接口中都定义了三个方法来处理被监听对象中的属性的增加，删除和替换的事件，同一个事件在这三个接口中对应的方法名称完全相同，只是接受的参数类型不同。</p>
<h4 id="attributeAdded-方法"><a href="#attributeAdded-方法" class="headerlink" title="attributeAdded 方法"></a>attributeAdded 方法</h4><p>当向被监听对象中增加一个属性时，web 容器就调用事件监听器的 <code>attributeAdded</code> 方法进行响应，这个方法接收一个事件类型的参数，监听器可以通过这个参数来获得正在增加属性的域对象和被保存到域中的属性对象<br>各个域属性监听器中的完整语法定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent scae)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(HttpSessionBindingEvent hsbe)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRmoved</span><span class="params">(ServletRequestAttributeEvent srae)</span></span><br></pre></td></tr></table></figure>

<h4 id="attributeRemoved-方法"><a href="#attributeRemoved-方法" class="headerlink" title="attributeRemoved 方法"></a>attributeRemoved 方法</h4><p>当删除被监听对象中的一个属性时，web 容器调用事件监听器的 <code>attributeRemoved</code> 方法进行响应<br>各个域属性监听器中的完整语法定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent scae)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(HttpSessionBindingEvent hsbe)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletRequestAttributeEvent srae)</span></span><br></pre></td></tr></table></figure>

<h4 id="attributeReplaced-方法"><a href="#attributeReplaced-方法" class="headerlink" title="attributeReplaced 方法"></a>attributeReplaced 方法</h4><p>当监听器的域对象中的某个属性被替换时，web 容器调用事件监听器的 <code>attributeReplaced</code> 方法进行响应<br>各个域属性监听器中的完整语法定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent scae)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(HttpSessionBindingEvent hsbe)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletRequestAttributeEvent srae)</span></span><br></pre></td></tr></table></figure>

<h3 id="监听-Session-内的对象"><a href="#监听-Session-内的对象" class="headerlink" title="监听 Session 内的对象"></a>监听 Session 内的对象</h3><p>保存在 Session 域中的对象可以有多种状态：</p>
<ul>
<li>绑定（<code>session.setAttribute(&quot;bean&quot;,Object)</code>）到 <code>Session</code> 中；</li>
<li>从 <code>Session</code> 域中解除绑定（<code>session.removeAttribute(&quot;bean&quot;)</code>）；</li>
<li>随 <code>Session</code> 对象持久化到一个存储设备中；</li>
<li>随 <code>Session</code> 对象从一个存储设备中恢复。</li>
</ul>
<p>Servlet 规范中定义了两个特殊的监听器接口 <code>HttpSessionBindingListener</code> 和<code>HttpSessionActivationListener</code> 来帮助 JavaBean 对象了解自己在 Session 域中的这些状态。</p>
<p>实现这两个接口的类不需要 <code>web.xml</code> 文件中进行注册。</p>
<h4 id="HttpSessionBindingListener"><a href="#HttpSessionBindingListener" class="headerlink" title="HttpSessionBindingListener"></a>HttpSessionBindingListener</h4><p><code>HttpSessionBindingListener</code> 接口的 JavaBean 对象可以感知自己被绑定或解绑定到 <code>Session</code> 中的事件。</p>
<ul>
<li>当对象被绑定到 <code>HttpSession</code> 对象中时，web 服务器调用该对象的 <code>valueBound(HttpSessionBindingEvent event)</code> 方法。</li>
<li>当对象从 <code>HttpSession</code> 对象中解除绑定时，web 服务器调用该对象的 <code>valueUnbound(HttpSessionBindingEvent event)</code> 方法。</li>
</ul>
<h4 id="HttpSessionActivationListener"><a href="#HttpSessionActivationListener" class="headerlink" title="HttpSessionActivationListener"></a>HttpSessionActivationListener</h4><p>实现了 <code>HttpSessionActivationListener</code> 接口的 JavaBean 对象可以感知自己被活化(反序列化)和钝化(序列化)的事件。</p>
<ul>
<li>当绑定到 <code>HttpSession</code> 对象中的 JavaBean 对象将要随 <code>HttpSession</code> 对象被序列化之前，web 服务器调用该 JavaBean 对象的 <code>sessionWillPassivate(HttpSessionEvent event)</code> 方法。这样 JavaBean 对象就可以知道自己将要和 <code>HttpSession</code> 对象一起被序列化到硬盘中.</li>
<li>当绑定到 <code>HttpSession</code> 对象中的 JavaBean 对象将要随 <code>HttpSession</code> 对象被反序列化之后，web 服务器调用该 JavaBean 对象的 <code>sessionDidActive(HttpSessionEvent event)</code> 方法。这样 JavaBean 对象就可以知道自己将要和 <code>HttpSession</code> 对象一起被反序列化回到内存中</li>
</ul>
<h2 id="Filter-和-Listener"><a href="#Filter-和-Listener" class="headerlink" title="Filter 和 Listener"></a>Filter 和 Listener</h2><p>Filter 和 Listener 的本质区别：</p>
<ul>
<li><strong>Filter 是干预过程的</strong>，它是过程的一部分，是基于过程行为的。</li>
<li><strong>Listener 是基于状态的</strong>，任何行为改变同一个状态，触发的事件是一致的。</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><ul>
<li><code>Filter</code> 的示例源码：<a target="_blank" rel="noopener" href="https://github.com/dunwu/javatech/tree/master/codes/javaee-tutorial/javaee-tutorial-filter">源码</a></li>
<li><code>Listener</code> 的示例源码：<a target="_blank" rel="noopener" href="https://github.com/dunwu/javatech/tree/master/codes/javaee-tutorial/javaee-tutorial-listener">源码</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100027701">深入拆解 Tomcat &amp; Jetty</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4189495/">Java Web 整合开发王者归来</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/c46bff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/c46bff/" class="post-title-link" itemprop="url">JavaWeb 之 Cookie 和 Session</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-24 19:41:46" itemprop="dateCreated datePublished" datetime="2020-08-24T19:41:46+08:00">2020-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 18:54:25" itemprop="dateModified" datetime="2022-09-23T18:54:25+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/JavaEE/JavaWeb/" itemprop="url" rel="index"><span itemprop="name">JavaWeb</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JavaWeb-之-Cookie-和-Session"><a href="#JavaWeb-之-Cookie-和-Session" class="headerlink" title="JavaWeb 之 Cookie 和 Session"></a>JavaWeb 之 Cookie 和 Session</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。</p>
<p>会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。</p>
<h3 id="Cookie-是什么"><a href="#Cookie-是什么" class="headerlink" title="Cookie 是什么"></a>Cookie 是什么</h3><p>Cookie 实际上是存储在客户端上的文本信息，并保留了各种跟踪的信息。</p>
<p><strong>Cookie 工作步骤：</strong></p>
<ol>
<li>客户端请求服务器，如果服务器需要记录该用户的状态，就是用 response 向客户端浏览器颁发一个 Cookie。</li>
<li>客户端浏览器会把 Cookie 保存下来。</li>
<li>当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。</li>
</ol>
<p><strong><em>注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。</em></strong></p>
<p>Java 中把 Cookie 封装成了<code>javax.servlet.http.Cookie</code>类。</p>
<h3 id="Cookie-剖析"><a href="#Cookie-剖析" class="headerlink" title="Cookie 剖析"></a>Cookie 剖析</h3><p>Cookies 通常设置在 HTTP 头信息中（虽然 JavaScript 也可以直接在浏览器上设置一个 Cookie）。</p>
<p>设置 Cookie 的 Servlet 会发送如下的头信息：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Fri, 04 Feb 2000 21:03:38 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/1.3.9 (UNIX) PHP/4.0b3</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT;</span><br><span class="line">                 path=/; domain=w3cschool.cc</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br></pre></td></tr></table></figure>

<p>正如您所看到的，<code>Set-Cookie</code> 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码。expires 字段是一个指令，告诉浏览器在给定的时间和日期之后”忘记”该 Cookie。</p>
<p>如果浏览器被配置为存储 Cookies，它将会保留此信息直到到期日期。如果用户的浏览器指向任何匹配该 Cookie 的路径和域的页面，它会重新发送 Cookie 到服务器。浏览器的头信息可能如下所示：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.0</span></span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>zink.demon.co.uk:1126</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>image/gif, */*</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en</span><br><span class="line"><span class="attribute">Accept-Charset</span><span class="punctuation">: </span>iso-8859-1,*,utf-8</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>name=xyz</span><br></pre></td></tr></table></figure>

<h3 id="Cookie-类中的方法"><a href="#Cookie-类中的方法" class="headerlink" title="Cookie 类中的方法"></a>Cookie 类中的方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>public void setDomain(String pattern)</td>
<td>该方法设置 cookie 适用的域。</td>
</tr>
<tr>
<td>public String getDomain()</td>
<td>该方法获取 cookie 适用的域。</td>
</tr>
<tr>
<td>public void setMaxAge(int expiry)</td>
<td>该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。</td>
</tr>
<tr>
<td>public int getMaxAge()</td>
<td>该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。</td>
</tr>
<tr>
<td>public String getName()</td>
<td>该方法返回 cookie 的名称。名称在创建后不能改变。</td>
</tr>
<tr>
<td>public void setValue(String newValue)</td>
<td>该方法设置与 cookie 关联的值。</td>
</tr>
<tr>
<td>public String getValue()</td>
<td>该方法获取与 cookie 关联的值。</td>
</tr>
<tr>
<td>public void setPath(String uri)</td>
<td>该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>该方法获取 cookie 适用的路径。</td>
</tr>
<tr>
<td>public void setSecure(boolean flag)</td>
<td>该方法设置布尔值，向浏览器指示，只会在 HTTPS 和 SSL 等安全协议中传输此类 Cookie。</td>
</tr>
<tr>
<td>public void setComment(String purpose)</td>
<td>该方法规定了描述 cookie 目的的注释。该注释在浏览器向用户呈现 cookie 时非常有用。</td>
</tr>
<tr>
<td>public String getComment()</td>
<td>该方法返回了描述 cookie 目的的注释，如果 cookie 没有注释则返回 null。</td>
</tr>
</tbody></table>
<h3 id="Cookie-的有效期"><a href="#Cookie-的有效期" class="headerlink" title="Cookie 的有效期"></a>Cookie 的有效期</h3><p><code>Cookie</code>的<code>maxAge</code>决定着 Cookie 的有效期，单位为秒。</p>
<p>如果 maxAge 为 0，则表示删除该 Cookie；</p>
<p>如果为负数，表示该 Cookie 仅在本浏览器中以及本窗口打开的子窗口内有效，关闭窗口后该 Cookie 即失效。</p>
<p>Cookie 中提供<code>getMaxAge()</code><strong>和</strong><code>setMaxAge(int expiry)</code>方法来读写<code>maxAge</code>属性。</p>
<h3 id="Cookie-的域名"><a href="#Cookie-的域名" class="headerlink" title="Cookie 的域名"></a>Cookie 的域名</h3><p>Cookie 是不可以跨域名的。域名 <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 颁发的 Cookie 不会被提交到域名 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 去。这是由 Cookie 的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的 Cookie。</p>
<p>正常情况下，同一个一级域名的两个二级域名之间也不能互相使用 Cookie。如果想让某域名下的子域名也可以使用该 Cookie，需要设置 Cookie 的 domain 参数。</p>
<p>Java 中使用<code>setDomain(Stringdomain)</code>和<code>getDomain()</code>方法来设置、获取 domain。</p>
<h3 id="Cookie-的路径"><a href="#Cookie-的路径" class="headerlink" title="Cookie 的路径"></a>Cookie 的路径</h3><p>Path 属性决定允许访问 Cookie 的路径。</p>
<p>Java 中使用<code>setPath(Stringuri)</code>和<code>getPath()</code>方法来设置、获取 path。</p>
<h3 id="Cookie-的安全属性"><a href="#Cookie-的安全属性" class="headerlink" title="Cookie 的安全属性"></a>Cookie 的安全属性</h3><p>HTTP 协议不仅是无状态的，而且是不安全的。</p>
<p>使用 HTTP 协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。如果不希望 Cookie 在 HTTP 等非安全协议中传输，可以设置 Cookie 的 secure 属性为 true。浏览器只会在 HTTPS 和 SSL 等安全协议中传输此类 Cookie。</p>
<p>Java 中使用<code>setSecure(booleanflag)</code>和<code>getSecure ()</code>方法来设置、获取 Secure。</p>
<h3 id="Cookie-实例"><a href="#Cookie-实例" class="headerlink" title="Cookie 实例"></a>Cookie 实例</h3><h4 id="添加-Cookie"><a href="#添加-Cookie" class="headerlink" title="添加 Cookie"></a>添加 Cookie</h4><p>通过 Servlet 添加 Cookies 包括三个步骤：</p>
<ol>
<li><p>创建一个 Cookie 对象：您可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串。</p>
</li>
<li><p>设置最大生存周期：您可以使用 <code>setMaxAge</code> 方法来指定 cookie 能够保持有效的时间（以秒为单位）。</p>
</li>
<li><p>发送 Cookie 到 HTTP 响应头：您可以使用 <code>response.addCookie</code> 来添加 HTTP 响应头中的 Cookies。</p>
</li>
</ol>
<p>AddCookies.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/servlet/AddCookies&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddCookies</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddCookies</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 为名字和姓氏创建 Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;name&quot;</span>, URLEncoder.encode(request.getParameter(<span class="string">&quot;name&quot;</span>), <span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">// 中文转码</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;url&quot;</span>, request.getParameter(<span class="string">&quot;url&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为两个 Cookie 设置过期日期为 24 小时后</span></span><br><span class="line">        name.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">        url.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在响应头中添加两个 Cookie</span></span><br><span class="line">        response.addCookie(name);</span><br><span class="line">        response.addCookie(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;设置 Cookie 实例&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">docType</span> <span class="operator">=</span> <span class="string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>;</span><br><span class="line">        out.println(docType + <span class="string">&quot;&lt;html&gt;\n&quot;</span> + <span class="string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span> + <span class="string">&quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot;</span> + title</span><br><span class="line">                        + <span class="string">&quot;&lt;/h1&gt;\n&quot;</span> + <span class="string">&quot;&lt;ul&gt;\n&quot;</span> + <span class="string">&quot;  &lt;li&gt;&lt;b&gt;站点名：&lt;/b&gt;：&quot;</span> + request.getParameter(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                        + <span class="string">&quot;\n&lt;/li&gt;&quot;</span> + <span class="string">&quot;  &lt;li&gt;&lt;b&gt;站点 URL：&lt;/b&gt;：&quot;</span> + request.getParameter(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">                        + <span class="string">&quot;\n&lt;/li&gt;&quot;</span> + <span class="string">&quot;&lt;/ul&gt;\n&quot;</span> + <span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>addCookies.jsp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">  &lt;title&gt;添加Cookie&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=/servlet/AddCookies method=<span class="string">&quot;GET&quot;</span>&gt;</span><br><span class="line">  站点名 ：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">  &lt;br/&gt;</span><br><span class="line">  站点 URL：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;url&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="显示-Cookie"><a href="#显示-Cookie" class="headerlink" title="显示 Cookie"></a>显示 Cookie</h4><p>要读取 Cookies，您需要通过调用 <code>HttpServletRequest</code> 的 <code>getCookies()</code> 方法创建一个 <code>javax.servlet.http.Cookie</code> 对象的数组。然后循环遍历数组，并使用 <code>getName()</code> 和 <code>getValue()</code> 方法来访问每个 cookie 和关联的值。</p>
<p>ReadCookies.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/servlet/ReadCookies&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadCookies</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadCookies</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Cookie[] cookies = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 获取与该域相关的 Cookie 的数组</span></span><br><span class="line">        cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;Delete Cookie Example&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">docType</span> <span class="operator">=</span> <span class="string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>;</span><br><span class="line">        out.println(docType + <span class="string">&quot;&lt;html&gt;\n&quot;</span> + <span class="string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="literal">null</span>) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;&lt;h2&gt;Cookie 名称和值&lt;/h2&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">                cookie = cookies[i];</span><br><span class="line">                <span class="keyword">if</span> ((cookie.getName()).compareTo(<span class="string">&quot;name&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">                    response.addCookie(cookie);</span><br><span class="line">                    out.print(<span class="string">&quot;已删除的 cookie：&quot;</span> + cookie.getName() + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.print(<span class="string">&quot;名称：&quot;</span> + cookie.getName() + <span class="string">&quot;，&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;值：&quot;</span> + URLDecoder.decode(cookie.getValue(), <span class="string">&quot;utf-8&quot;</span>) + <span class="string">&quot; &lt;br/&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.println(<span class="string">&quot;&lt;h2 class=\&quot;tutheader\&quot;&gt;No Cookie founds&lt;/h2&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除-Cookie"><a href="#删除-Cookie" class="headerlink" title="删除 Cookie"></a>删除 Cookie</h4><p>Java 中并没有提供直接删除 Cookie 的方法，如果想要删除一个 Cookie，直接将这个 Cookie 的有效期设为 0 就可以了。步骤如下：</p>
<ol>
<li><p>读取一个现有的 cookie，并把它存储在 Cookie 对象中。</p>
</li>
<li><p>使用 <code>setMaxAge()</code> 方法设置 cookie 的年龄为零，来删除现有的 cookie。</p>
</li>
<li><p>把这个 cookie 添加到响应头。</p>
</li>
</ol>
<p>DeleteCookies.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/servlet/DeleteCookies&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteCookies</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#HttpServlet()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeleteCookies</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Cookie[] cookies = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 获取与该域相关的 Cookie 的数组</span></span><br><span class="line">        cookies = request.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;删除 Cookie 实例&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">docType</span> <span class="operator">=</span> <span class="string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>;</span><br><span class="line">        out.println(docType + <span class="string">&quot;&lt;html&gt;\n&quot;</span> + <span class="string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="literal">null</span>) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;&lt;h2&gt;Cookie 名称和值&lt;/h2&gt;&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">                cookie = cookies[i];</span><br><span class="line">                <span class="keyword">if</span> ((cookie.getName()).compareTo(<span class="string">&quot;url&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">                    response.addCookie(cookie);</span><br><span class="line">                    out.print(<span class="string">&quot;已删除的 cookie：&quot;</span> + cookie.getName() + <span class="string">&quot;&lt;br/&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.print(<span class="string">&quot;名称：&quot;</span> + cookie.getName() + <span class="string">&quot;，&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;值：&quot;</span> + cookie.getValue() + <span class="string">&quot; &lt;br/&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.println(<span class="string">&quot;&lt;h2 class=\&quot;tutheader\&quot;&gt;No Cookie founds&lt;/h2&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="Session-是什么"><a href="#Session-是什么" class="headerlink" title="Session 是什么"></a>Session 是什么</h3><p>不同于 Cookie 保存在客户端浏览器中，Session 保存在服务器上。</p>
<p>如果说 Cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 Session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。</p>
<p>Session 对应的类为 <code>javax.servlet.http.HttpSession</code> 类。Session 对象是在客户第一次请求服务器时创建的。</p>
<h3 id="Session-类中的方法"><a href="#Session-类中的方法" class="headerlink" title="Session 类中的方法"></a>Session 类中的方法</h3><p><code>javax.servlet.http.HttpSession</code> 类中的方法：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public Object getAttribute(String name)</td>
<td>该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。</td>
</tr>
<tr>
<td>public Enumeration getAttributeNames()</td>
<td>该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。</td>
</tr>
<tr>
<td>public long getCreationTime()</td>
<td>该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td>
</tr>
<tr>
<td>public String getId()</td>
<td>该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。</td>
</tr>
<tr>
<td>public long getLastAccessedTime()</td>
<td>该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。</td>
</tr>
<tr>
<td>public int getMaxInactiveInterval()</td>
<td>该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。</td>
</tr>
<tr>
<td>public void invalidate()</td>
<td>该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。</td>
</tr>
<tr>
<td>public boolean isNew()</td>
<td>如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。</td>
</tr>
<tr>
<td>public void removeAttribute(String name)</td>
<td>该方法将从该 session 会话移除指定名称的对象。</td>
</tr>
<tr>
<td>public void setAttribute(String name, Object value)</td>
<td>该方法使用指定的名称绑定一个对象到该 session 会话。</td>
</tr>
<tr>
<td>public void setMaxInactiveInterval(int interval)</td>
<td>该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。</td>
</tr>
</tbody></table>
<h3 id="Session-的有效期"><a href="#Session-的有效期" class="headerlink" title="Session 的有效期"></a>Session 的有效期</h3><p>由于会有越来越多的用户访问服务器，因此 Session 也会越来越多。为防止内存溢出，服务器会把长时间没有活跃的 Session 从内存中删除。</p>
<p>Session 的超时时间为<code>maxInactiveInterval</code>属性，可以通过<code>getMaxInactiveInterval()</code>、<code>setMaxInactiveInterval(longinterval)</code>来读写这个属性。</p>
<p>Tomcat 中 Session 的默认超时时间为 20 分钟。可以修改 web.xml 改变 Session 的默认超时时间。</p>
<p>例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Session-对浏览器的要求"><a href="#Session-对浏览器的要求" class="headerlink" title="Session 对浏览器的要求"></a>Session 对浏览器的要求</h3><p>HTTP 协议是无状态的，Session 不能依据 HTTP 连接来判断是否为同一客户。因此服务器向客户端浏览器发送一个名为 JESSIONID 的 Cookie，他的值为该 Session 的 id（也就是 HttpSession.getId()的返回值）。Session 依据该 Cookie 来识别是否为同一用户。</p>
<p>该 Cookie 为服务器自动生成的，它的<code>maxAge</code>属性一般为-1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。</p>
<h3 id="URL-地址重写"><a href="#URL-地址重写" class="headerlink" title="URL 地址重写"></a>URL 地址重写</h3><p>URL 地址重写的原理是将该用户 Session 的 id 信息重写到 URL 地址中。服务器能够解析重写后的 URL 获取 Session 的 id。这样即使客户端不支持 Cookie，也可以使用 Session 来记录用户状态。</p>
<p><code>HttpServletResponse</code>类提供了<code>encodeURL(Stringurl)</code>实现 URL 地址重写。</p>
<h3 id="Session-中禁用-Cookie"><a href="#Session-中禁用-Cookie" class="headerlink" title="Session 中禁用 Cookie"></a>Session 中禁用 Cookie</h3><p>在<code>META-INF/context.xml</code>中编辑如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/SessionNotes&quot;</span> <span class="attr">cookies</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>部署后，TOMCAT 便不会自动生成名 JESSIONID 的 Cookie，Session 也不会以 Cookie 为识别标志，而仅仅以重写后的 URL 地址为识别标志了。</p>
<h3 id="Session-实例"><a href="#Session-实例" class="headerlink" title="Session 实例"></a>Session 实例</h3><h4 id="Session-跟踪"><a href="#Session-跟踪" class="headerlink" title="Session 跟踪"></a>Session 跟踪</h4><p>SessionTrackServlet.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/servlet/SessionTrackServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionTrackServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">                    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 如果不存在 session 会话，则创建一个 session 对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取 session 创建时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">createTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(session.getCreationTime());</span><br><span class="line">        <span class="comment">// 获取该网页的最后一次访问时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">lastAccessTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(session.getLastAccessedTime());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置日期输出的格式</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;Servlet Session 实例&quot;</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">visitCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">visitCountKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;visitCount&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userIDKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;userID&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查网页上是否有新的访问者</span></span><br><span class="line">        <span class="keyword">if</span> (session.isNew()) &#123;</span><br><span class="line">            session.setAttribute(userIDKey, userID);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            visitCount = (Integer) session.getAttribute(visitCountKey);</span><br><span class="line">            visitCount = visitCount + <span class="number">1</span>;</span><br><span class="line">            userID = (String) session.getAttribute(userIDKey);</span><br><span class="line">        &#125;</span><br><span class="line">        session.setAttribute(visitCountKey, visitCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">docType</span> <span class="operator">=</span> <span class="string">&quot;&lt;!DOCTYPE html&gt;\n&quot;</span>;</span><br><span class="line">        out.println(docType + <span class="string">&quot;&lt;html&gt;\n&quot;</span> + <span class="string">&quot;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="string">&quot;&lt;/title&gt;&lt;/head&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;&lt;body bgcolor=\&quot;#f0f0f0\&quot;&gt;\n&quot;</span> + <span class="string">&quot;&lt;h1 align=\&quot;center\&quot;&gt;&quot;</span> + title</span><br><span class="line">                        + <span class="string">&quot;&lt;/h1&gt;\n&quot;</span> + <span class="string">&quot;&lt;h2 align=\&quot;center\&quot;&gt;Session 信息&lt;/h2&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;&lt;table border=\&quot;1\&quot; align=\&quot;center\&quot;&gt;\n&quot;</span> + <span class="string">&quot;&lt;tr bgcolor=\&quot;#949494\&quot;&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;  &lt;th&gt;Session 信息&lt;/th&gt;&lt;th&gt;值&lt;/th&gt;&lt;/tr&gt;\n&quot;</span> + <span class="string">&quot;&lt;tr&gt;\n&quot;</span> + <span class="string">&quot;  &lt;td&gt;id&lt;/td&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;  &lt;td&gt;&quot;</span> + session.getId() + <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span> + <span class="string">&quot;&lt;tr&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;  &lt;td&gt;创建时间&lt;/td&gt;\n&quot;</span> + <span class="string">&quot;  &lt;td&gt;&quot;</span> + df.format(createTime) + <span class="string">&quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot;</span></span><br><span class="line">                        + <span class="string">&quot;&lt;tr&gt;\n&quot;</span> + <span class="string">&quot;  &lt;td&gt;最后访问时间&lt;/td&gt;\n&quot;</span> + <span class="string">&quot;  &lt;td&gt;&quot;</span> + df.format(lastAccessTime)</span><br><span class="line">                        + <span class="string">&quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot;</span> + <span class="string">&quot;&lt;tr&gt;\n&quot;</span> + <span class="string">&quot;  &lt;td&gt;用户 ID&lt;/td&gt;\n&quot;</span> + <span class="string">&quot;  &lt;td&gt;&quot;</span> + userID</span><br><span class="line">                        + <span class="string">&quot;  &lt;/td&gt;&lt;/tr&gt;\n&quot;</span> + <span class="string">&quot;&lt;tr&gt;\n&quot;</span> + <span class="string">&quot;  &lt;td&gt;访问统计：&lt;/td&gt;\n&quot;</span> + <span class="string">&quot;  &lt;td&gt;&quot;</span> + visitCount</span><br><span class="line">                        + <span class="string">&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;</span> + <span class="string">&quot;&lt;/table&gt;\n&quot;</span> + <span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SessionTrackServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>SessionTrackServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SessionTrackServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/SessionTrackServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="删除-Session-会话数据"><a href="#删除-Session-会话数据" class="headerlink" title="删除 Session 会话数据"></a>删除 Session 会话数据</h4><p>当您完成了一个用户的 session 会话数据，您有以下几种选择：</p>
<p><strong>移除一个特定的属性：</strong>您可以调用 <code>removeAttribute(String name)</code> 方法来删除与特定的键相关联的值。</p>
<p><strong>删除整个 session 会话：</strong>您可以调用 <code>invalidate()</code> 方法来丢弃整个 session 会话。</p>
<p><strong>设置 session 会话过期时间：</strong>您可以调用 <code>setMaxInactiveInterval(int interval)</code> 方法来单独设置 session 会话超时。</p>
<p><strong>注销用户：</strong>如果使用的是支持 servlet 2.4 的服务器，您可以调用 <code>logout</code> 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。</p>
<p><strong>web.xml 配置：</strong>如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。</p>
<p>在一个 Servlet 中的 <code>getMaxInactiveInterval()</code> 方法会返回 session 会话的超时时间，以秒为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么<code>getMaxInactiveInterval()</code> 会返回 900。</p>
<h2 id="Cookie-vs-Session"><a href="#Cookie-vs-Session" class="headerlink" title="Cookie vs Session"></a>Cookie vs Session</h2><h3 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h3><p>Cookie 只能保存<code>ASCII</code>字符串，如果需要存取 Unicode 字符或二进制数据，需要进行<code>UTF-8</code>、<code>GBK</code>或<code>BASE64</code>等方式的编码。</p>
<p>Session 可以存取任何类型的数据，甚至是任何 Java 类。可以将 Session 看成是一个 Java 容器类。</p>
<h3 id="隐私安全"><a href="#隐私安全" class="headerlink" title="隐私安全"></a>隐私安全</h3><p>Cookie 存于客户端浏览器，一些客户端的程序可能会窥探、复制或修改 Cookie 内容。</p>
<p>Session 存于服务器，对客户端是透明的，不存在敏感信息泄露的危险。</p>
<h3 id="有效期"><a href="#有效期" class="headerlink" title="有效期"></a>有效期</h3><p>使用 Cookie 可以保证长时间登录有效，只要设置 Cookie 的<code>maxAge</code>属性为一个很大的数字。</p>
<p>而 Session 虽然理论上也可以通过设置很大的数值来保持长时间登录有效，但是，由于 Session 依赖于名为<code>JESSIONID</code>的 Cookie，而 Cookie <code>JESSIONID</code>的<code>maxAge</code>默认为-1，只要关闭了浏览器该 Session 就会失效，因此，Session 不能实现信息永久有效的效果。使用 URL 地址重写也不能实现。</p>
<h3 id="服务器的开销"><a href="#服务器的开销" class="headerlink" title="服务器的开销"></a>服务器的开销</h3><p>由于 Session 是保存在服务器的，每个用户都会产生一个 Session，如果并发访问的用户非常多，会产生很多的 Session，消耗大量的内存。</p>
<p>而 Cookie 由于保存在客户端浏览器上，所以不占用服务器资源。</p>
<h3 id="浏览器的支持"><a href="#浏览器的支持" class="headerlink" title="浏览器的支持"></a>浏览器的支持</h3><p>Cookie 需要浏览器支持才能使用。</p>
<p>如果浏览器不支持 Cookie，需要使用 Session 以及 URL 地址重写。</p>
<p>需要注意的事所有的用到 Session 程序的 URL 都要使用<code>response.encodeURL(StringURL)</code> 或<code>response.encodeRediretURL(String URL)</code>进行 URL 地址重写，否则导致 Session 会话跟踪失效。</p>
<h3 id="跨域名"><a href="#跨域名" class="headerlink" title="跨域名"></a>跨域名</h3><ul>
<li>Cookie 支持跨域名。</li>
<li>Session 不支持跨域名。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/e51064/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/e51064/" class="post-title-link" itemprop="url">错误处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-13 23:32:37" itemprop="dateCreated datePublished" datetime="2020-08-13T23:32:37+08:00">2020-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 18:54:25" itemprop="dateModified" datetime="2022-09-23T18:54:25+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">编程范式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="错误的分类"><a href="#错误的分类" class="headerlink" title="错误的分类"></a>错误的分类</h2><h4 id="资源的错误"><a href="#资源的错误" class="headerlink" title="资源的错误"></a>资源的错误</h4><p>当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的文件，写文件时出现的写错误，发送文件到网络端发现网络故障的错误，等等。<strong>这一类错误属于程序运行环境的问题。对于这类错误，有的我们可以处理，有的我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源不能满足等等这些情况，我们只能停止运行，甚至退出整个程序。</strong></p>
<h4 id="程序的错误"><a href="#程序的错误" class="headerlink" title="程序的错误"></a>程序的错误</h4><p>比如：空指针、非法参数等。<strong>这类是我们自己程序的错误，我们要记录下来，写入日志，最好触发监控系统报警</strong>。</p>
<h4 id="用户的错误"><a href="#用户的错误" class="headerlink" title="用户的错误"></a>用户的错误</h4><p>比如：Bad Request、Bad Format 等这类由用户不合法输入带来的错误。<strong>这类错误基本上是在用户的 API 层上出现的问题</strong>。比如，解析一个 XML 或 JSON 文件，或是用户输入的字段不合法之类的。</p>
<p><strong>对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。然后，我们正常执行，但是需要做统计，统计相应的错误率，这样有利于我们改善软件或是侦测是否有恶意的用户请求。</strong></p>
<h2 id="错误返回码和异常捕捉"><a href="#错误返回码和异常捕捉" class="headerlink" title="错误返回码和异常捕捉"></a>错误返回码和异常捕捉</h2><p>错误处理一般有两种方式：错误返回码和异常捕捉。</p>
<ul>
<li>对于我们并不期望会发生的事，我们可以使用异常捕捉；</li>
<li>对于我们觉得可能会发生的事，使用返回码。</li>
</ul>
<h2 id="异步编程的错误处理"><a href="#异步编程的错误处理" class="headerlink" title="异步编程的错误处理"></a>异步编程的错误处理</h2><ul>
<li><strong>无法使用返回码</strong>。因为函数在“被”异步运行中，所谓的返回只是把处理权交给下一条指令，而不是把函数运行完的结果返回。<strong>所以，函数返回的语义完全变了，返回码也没有用了</strong>。</li>
<li><strong>无法使用抛异常的方式</strong>。因为除了上述的函数立马返回的原因之外，抛出的异常也在另外一个线程中，不同线程中的栈是完全不一样的，所以主线程的 <code>catch</code> 完全看不到另外一个线程中的异常。</li>
</ul>
<h3 id="callback-错误处理"><a href="#callback-错误处理" class="headerlink" title="callback 错误处理"></a>callback 错误处理</h3><p>异步编程中，最常用的错误处理方式就是 <code>callback</code> 方式。在做异步请求的时候，注册几个 <code>OnSuccess()</code>、 <code>OnFailure()</code> 这样的函数，让在另一个线程中运行的异步代码来回调过来。</p>
<p>【示例】JavaScript 异步编程的错误处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">successCallback</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;It succeeded with &#x27;</span> + result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">failureCallback</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;It failed with &#x27;</span> + error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(successCallback, failureCallback)</span><br></pre></td></tr></table></figure>

<p>但是， 如果我们需要把几个异步函数顺序执行的话（异步程序中，程序执行的顺序是不可预测的、也是不确定的，而有时候，函数被调用的上下文是有相互依赖的，所以，我们希望它们能按一定的顺序处理），就会出现了所谓的 Callback Hell 的问题。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="title function_">doSomethingElse</span>(</span><br><span class="line">    result,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">newResult</span>) &#123;</span><br><span class="line">      <span class="title function_">doThirdThing</span>(</span><br><span class="line">        newResult,</span><br><span class="line">        <span class="keyword">function</span>(<span class="params">finalResult</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult)</span><br><span class="line">        &#125;,</span><br><span class="line">        failureCallback</span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">    failureCallback</span><br><span class="line">  )</span><br><span class="line">&#125;, failureCallback)</span><br></pre></td></tr></table></figure>

<p>而这样层层嵌套中需要注册的错误处理函数也有可能是完全不一样的，而且会导致代码非常混乱，难以阅读和维护。</p>
<h3 id="JavaScript-的-Promise-错误处理"><a href="#JavaScript-的-Promise-错误处理" class="headerlink" title="JavaScript 的 Promise 错误处理"></a>JavaScript 的 Promise 错误处理</h3><p>在异步编程的实践里，使用 Promise 模式来处理更为优雅。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="title function_">doSomethingElse</span>(result))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">newResult</span> =&gt;</span> <span class="title function_">doThirdThing</span>(newResult))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">finalResult</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Got the final result: <span class="subst">$&#123;finalResult&#125;</span>`</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(failureCallback);</span><br></pre></td></tr></table></figure>

<p>上面代码中的 <code>then()</code> 和 <code>catch()</code> 方法就是 Promise 对象的方法，<code>then()</code>方法可以把各个异步的函数给串联起来，而<code>catch()</code> 方法则是出错的处理。</p>
<p>看到上面的那个级联式的调用方式，这就要我们的 <code>doSomething()</code> 函数返回 Promise 对象，下面是这个函数的相关代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>();</span><br><span class="line">	<span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">	xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://coolshell.cn/....&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            results = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span><br><span class="line">            promise.<span class="title function_">resolve</span>(results); <span class="comment">// 成功时，调用 resolve() 方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        promise.<span class="title function_">reject</span>(e); <span class="comment">// 失败时，调用 reject() 方法</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.<span class="title function_">send</span>();</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码示例中，我们可以看到，如果成功了，要调用<br><code>Promise.resolve()</code> 方法，这样 Promise 对象会继续调用下一个 <code>then()</code>。如果出错了就调用 <code>Promise.reject()</code> 方法，这样就会忽略后面的 <code>then()</code> 直到 <code>catch()</code> 方法。</p>
<p>我们可以看到 <code>Promise.reject()</code> 就像是抛异常一样。这个编程模式让我们的代码组织方便了很多。</p>
<p>另外，多说一句，Promise 还可以同时等待两个不同的异步方法。比如下面的代码所展示的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise1 = <span class="title function_">doSomething</span>();</span><br><span class="line">promise2 = <span class="title function_">doSomethingElse</span>();</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">when</span>(promise1, promise2).<span class="title function_">then</span>( <span class="keyword">function</span> (<span class="params">result1, result2</span>) &#123;</span><br><span class="line">	... <span class="comment">// 处理 result1 和 result2 的代码</span></span><br><span class="line">&#125;, handleError);</span><br></pre></td></tr></table></figure>

<p>在 ECMAScript 2017 的标准中，我们可以使用<code>async</code>&#x2F;<code>await</code> 这两个关键字来取代 Promise 对象，这样可以让我们的代码更易读。</p>
<p>比如下面的代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">doSomething</span>();</span><br><span class="line">    <span class="keyword">let</span> newResult = <span class="keyword">await</span> <span class="title function_">doSomethingElse</span>(result);</span><br><span class="line">    <span class="keyword">let</span> finalResult = <span class="keyword">await</span> <span class="title function_">doThirdThing</span>(newResult);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Got the final result: <span class="subst">$&#123;finalResult&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="title function_">failureCallback</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在函数定义之前使用了 <code>async</code> 关键字，就可以在函数内使用 <code>await</code>。 当在 <code>await</code> 某个 <code>Promise</code> 时，函数暂停执行，直至该 <code>Promise</code> 产生结果，并且暂停不会阻塞主线程。 如果 <code>Promise</code> resolve，则会返回值。 如果 <code>Promise</code> reject，则会抛出拒绝的值。</p>
<h3 id="Java-的-Promise-模式"><a href="#Java-的-Promise-模式" class="headerlink" title="Java 的 Promise 模式"></a>Java 的 Promise 模式</h3><p>在 JDK 1.8 里也引入了类似 JavaScript 的玩法 —— <code>CompletableFuture</code>。这个类提供了大量的异步编程中 Promise 的各种方式。</p>
<p>链式处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(<span class="built_in">this</span>::findReceiver)</span><br><span class="line">                 .thenApply(<span class="built_in">this</span>::sendMsg)</span><br><span class="line">                 .thenAccept(<span class="built_in">this</span>::notify);</span><br></pre></td></tr></table></figure>

<p>上面的这个链式处理和 JavaScript 中的<code>then()</code>方法很像，其中的<br><code>supplyAsync()</code> 表示执行一个异步方法，而 <code>thenApply()</code> 表示执行成功后再串联另外一个异步方法，最后是 <code>thenAccept()</code> 来处理最终结果。</p>
<p>下面这个例子是要合并两个异步函数的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">     &#125;).thenCombine(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">     &#125;), (s1, s2) -&gt; s1 + <span class="string">&quot; &quot;</span> + s2).join());</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们再来看一下，Java 这个类相关的异常处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(Integer::parseInt) <span class="comment">// 输入: &quot;ILLEGAL&quot;</span></span><br><span class="line">			     .thenApply(r -&gt; r * <span class="number">2</span> * Math.PI)</span><br><span class="line">			     .thenApply(s -&gt; <span class="string">&quot;apply&gt;&gt; &quot;</span> + s)</span><br><span class="line">			     .exceptionally(ex -&gt; <span class="string">&quot;Error: &quot;</span> + ex.getMessage());</span><br></pre></td></tr></table></figure>

<p>我们要注意到上面代码里的 <code>exceptionally()</code> 方法，这个和 JavaScript Promise 中的 <code>catch()</code> 方法相似。</p>
<p>运行上面的代码，会出现如下输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: java.lang.NumberFormatException: For input string: <span class="string">&quot;ILLEGAL&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(Integer::parseInt) <span class="comment">// 输入: &quot;ILLEGAL&quot;</span></span><br><span class="line">				 .thenApply(r -&gt; r * <span class="number">2</span> * Math.PI)</span><br><span class="line">				 .thenApply(s -&gt; <span class="string">&quot;apply&gt;&gt; &quot;</span> + s)</span><br><span class="line">				 .handle((result, ex) -&gt; &#123;</span><br><span class="line">				 	<span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">				 		<span class="keyword">return</span> result;</span><br><span class="line">				 	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				 		<span class="keyword">return</span> <span class="string">&quot;Error handling: &quot;</span> + ex.getMessage();</span><br><span class="line">				 	&#125;</span><br><span class="line">				 &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，你可以看到，其使用了 <code>handle()</code> 方法来处理最终的结果，其中包含了异步函数中的错误处理。</p>
<h2 id="错误处理的最佳实践"><a href="#错误处理的最佳实践" class="headerlink" title="错误处理的最佳实践"></a>错误处理的最佳实践</h2><ul>
<li><strong>统一分类的错误字典</strong>。无论你是使用错误码还是异常捕捉，都需要认真并统一地做好错误的分类。最好是在一个地方定义相关的错误。比如，HTTP 的 4XX 表示客户端有问题，5XX 则表示服务端有问题。也就是说，你要建立一个错误字典。</li>
<li><strong>同类错误的定义最好是可以扩展的</strong>。这一点非常重要，而对于这一点，通过面向对象的继承或是像 Go 语言那样的接口多态可以很好地做到。这样可以方便地重用已有的代码。</li>
<li><strong>定义错误的严重程度</strong>。比如，Fatal 表示重大错误，Error 表示资源或需求得不到满足，Warning 表示并不一定是个错误但还是需要引起注意，Info 表示不是错误只是一个信息，Debug 表示这是给内部开发人员用于调试程序的。</li>
<li><strong>错误日志的输出最好使用错误码，而不是错误信息</strong>。打印错误日志的时候，应该使用统一的格式。但最好不要用错误信息，而应使用相应的错误码，错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件进行自动化监控，而不是要从错误信息中做语义分析。比如：HTTP 的日志中就会有 HTTP 的返回码，如：<code>404</code>。但我更推荐使用像<code>PageNotFound</code>这样的标识，这样人和机器都很容易处理。</li>
<li><strong>忽略错误最好有日志</strong>。不然会给维护带来很大的麻烦。</li>
<li><strong>对于同一个地方不停的报错，最好不要都打到日志里</strong>。不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。</li>
<li><strong>不要用错误处理逻辑来处理业务逻辑</strong>。也就是说，不要使用异常捕捉这样的方式来处理业务逻辑，而是应该用条件判断。如果一个逻辑控制可以用 if - else 清楚地表达，那就不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事情，而错误码则用来处理可能会发生的事。</li>
<li><strong>对于同类的错误处理，用一样的模式</strong>。比如，对于<code>null</code>对象的错误，要么都用返回 null，加上条件检查的模式，要么都用抛 NullPointerException 的方式处理。不要混用，这样有助于代码规范。</li>
<li><strong>尽可能在错误发生的地方处理错误</strong>。因为这样会让调用者变得更简单。</li>
<li><strong>向上尽可能地返回原始的错误</strong>。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。</li>
<li><strong>处理错误时，总是要清理已分配的资源</strong>。这点非常关键，使用 RAII 技术，或是 try-catch-finally，或是 Go 的 defer 都可以容易地做到。</li>
<li><strong>不推荐在循环体里处理错误</strong>。这里说的是 try-catch，绝大多数的情况你不需要这样做。最好把整个循环体外放在 try 语句块内，而在外面做 catch。</li>
<li><strong>不要把大量的代码都放在一个 try 语句块内</strong>。一个 try 语句块内的语句应该是完成一个简单单一的事情。</li>
<li><strong>为你的错误定义提供清楚的文档以及每种错误的代码示例</strong>。如果你是做 RESTful API 方面的，使用 Swagger 会帮你很容易搞定这个事。</li>
<li><strong>对于异步的方式，推荐使用 Promise 模式处理错误</strong>。对于这一点，JavaScript 中有很好的实践。</li>
<li><strong>对于分布式的系统，推荐使用 APM 相关的软件</strong>。尤其是使用 Zipkin 这样的服务调用跟踪的分析来关联错误。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/430f53/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/430f53/" class="post-title-link" itemprop="url">SpringBoot 知识图谱</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-12 07:01:26" itemprop="dateCreated datePublished" datetime="2020-08-12T07:01:26+08:00">2020-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 18:54:25" itemprop="dateModified" datetime="2022-09-23T18:54:25+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">SpringBoot综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>35k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>32 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SpringBoot-知识图谱"><a href="#SpringBoot-知识图谱" class="headerlink" title="SpringBoot 知识图谱"></a>SpringBoot 知识图谱</h1><blockquote>
<ol>
<li>预警：本文非常长，建议先 mark 后看，也许是最后一次写这么长的文章</li>
<li>说明：前面有 4 个小节关于 Spring 的基础知识，分别是：IOC 容器、JavaConfig、事件监听、SpringFactoriesLoader 详解，它们占据了本文的大部分内容，虽然它们之间可能没有太多的联系，但这些知识对于理解 Spring Boot 的核心原理至关重要，如果你对 Spring 框架烂熟于心，完全可以跳过这 4 个小节。正是因为这个系列的文章是由这些看似不相关的知识点组成，因此取名知识清单。</li>
</ol>
</blockquote>
<p>在过去两三年的 Spring 生态圈，最让人兴奋的莫过于 Spring Boot 框架。或许从命名上就能看出这个框架的设计初衷：快速的启动 Spring 应用。因而 Spring Boot 应用本质上就是一个基于 Spring 框架的应用，它是 Spring 对“约定优先于配置”理念的最佳实践产物，它能够帮助开发者更快速高效地构建基于 Spring 生态圈的应用。</p>
<p>那 Spring Boot 有何魔法？<strong>自动配置</strong>、<strong>起步依赖</strong>、<strong>Actuator</strong>、<strong>命令行界面(CLI)</strong> 是 Spring Boot 最重要的 4 大核心特性，其中 CLI 是 Spring Boot 的可选特性，虽然它功能强大，但也引入了一套不太常规的开发模型，因而这个系列的文章仅关注其它 3 种特性。如文章标题，本文是这个系列的第一部分，将为你打开 Spring Boot 的大门，重点为你剖析其启动流程以及自动配置实现原理。要掌握这部分核心内容，理解一些 Spring 框架的基础知识，将会让你事半功倍。</p>
<h2 id="一、抛砖引玉：探索-Spring-IoC-容器"><a href="#一、抛砖引玉：探索-Spring-IoC-容器" class="headerlink" title="一、抛砖引玉：探索 Spring IoC 容器"></a>一、抛砖引玉：探索 Spring IoC 容器</h2><p>如果有看过<code>SpringApplication.run()</code>方法的源码，Spring Boot 冗长无比的启动流程一定会让你抓狂，透过现象看本质，SpringApplication 只是将一个典型的 Spring 应用的启动流程进行了扩展，因此，透彻理解 Spring 容器是打开 Spring Boot 大门的一把钥匙。</p>
<h3 id="1-1、Spring-IoC-容器"><a href="#1-1、Spring-IoC-容器" class="headerlink" title="1.1、Spring IoC 容器"></a>1.1、Spring IoC 容器</h3><p>可以把 Spring IoC 容器比作一间餐馆，当你来到餐馆，通常会直接招呼服务员：点菜！至于菜的原料是什么？如何用原料把菜做出来？可能你根本就不关心。IoC 容器也是一样，你只需要告诉它需要某个 bean，它就把对应的实例（instance）扔给你，至于这个 bean 是否依赖其他组件，怎样完成它的初始化，根本就不需要你关心。</p>
<p>作为餐馆，想要做出菜肴，得知道菜的原料和菜谱，同样地，IoC 容器想要管理各个业务对象以及它们之间的依赖关系，需要通过某种途径来记录和管理这些信息。<code>BeanDefinition</code>对象就承担了这个责任：容器中的每一个 bean 都会有一个对应的 BeanDefinition 实例，该实例负责保存 bean 对象的所有必要信息，包括 bean 对象的 class 类型、是否是抽象类、构造方法和参数、其它属性等等。当客户端向容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的 bean 实例。</p>
<p>原材料已经准备好（把 BeanDefinition 看着原料），开始做菜吧，等等，你还需要一份菜谱，<code>BeanDefinitionRegistry</code>和<code>BeanFactory</code>就是这份菜谱，BeanDefinitionRegistry 抽象出 bean 的注册逻辑，而 BeanFactory 则抽象出了 bean 的管理逻辑，而各个 BeanFactory 的实现类就具体承担了 bean 的注册以及管理工作。它们之间的关系就如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165bd49d06649b0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"> <em>BeanFactory、BeanDefinitionRegistry 关系图（来自：Spring 揭秘）</em></p>
<p><code>DefaultListableBeanFactory</code>作为一个比较通用的 BeanFactory 实现，它同时也实现了 BeanDefinitionRegistry 接口，因此它就承担了 Bean 的注册管理工作。从图中也可以看出，BeanFactory 接口中主要包含 getBean、containBean、getType、getAliases 等管理 bean 的方法，而 BeanDefinitionRegistry 接口则包含 registerBeanDefinition、removeBeanDefinition、getBeanDefinition 等注册管理 BeanDefinition 的方法。</p>
<p>下面通过一段简单的代码来模拟 BeanFactory 底层是如何工作的：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认容器实现</span></span><br><span class="line">DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> <span class="constructor">DefaultListableBeanFactory()</span>;</span><br><span class="line"><span class="comment">// 根据业务对象构造相应的BeanDefinition</span></span><br><span class="line">AbstractBeanDefinition definition = <span class="keyword">new</span> <span class="constructor">RootBeanDefinition(Business.<span class="params">class</span>,<span class="params">true</span>)</span>;</span><br><span class="line"><span class="comment">// 将bean定义注册到容器中</span></span><br><span class="line">beanRegistry.register<span class="constructor">BeanDefinition(<span class="string">&quot;beanName&quot;</span>,<span class="params">definition</span>)</span>;</span><br><span class="line"><span class="comment">// 如果有多个bean，还可以指定各个bean之间的依赖关系</span></span><br><span class="line"><span class="comment">// ........</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后可以从容器中获取这个bean的实例</span></span><br><span class="line"><span class="comment">// 注意：这里的beanRegistry其实实现了BeanFactory接口，所以可以强转，</span></span><br><span class="line"><span class="comment">// 单纯的BeanDefinitionRegistry是无法强制转换到BeanFactory类型的</span></span><br><span class="line">BeanFactory container = (BeanFactory)beanRegistry;</span><br><span class="line">Business business = (Business)container.get<span class="constructor">Bean(<span class="string">&quot;beanName&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码仅为了说明 BeanFactory 底层的大致工作流程，实际情况会更加复杂，比如 bean 之间的依赖关系可能定义在外部配置文件(XML&#x2F;Properties)中、也可能是注解方式。Spring IoC 容器的整个工作流程大致可以分为两个阶段：</p>
<p>①、容器启动阶段</p>
<p>容器启动时，会通过某种途径加载<code>Configuration MetaData</code>。除了代码方式比较直接外，在大部分情况下，容器需要依赖某些工具类，比如：<code>BeanDefinitionReader</code>，BeanDefinitionReader 会对加载的<code>Configuration MetaData</code>进行解析和分析，并将分析后的信息组装为相应的 BeanDefinition，最后把这些保存了 bean 定义的 BeanDefinition，注册到相应的 BeanDefinitionRegistry，这样容器的启动工作就完成了。这个阶段主要完成一些准备性工作，更侧重于 bean 对象管理信息的收集，当然一些验证性或者辅助性的工作也在这一阶段完成。</p>
<p>来看一个简单的例子吧，过往，所有的 bean 都定义在 XML 配置文件中，下面的代码将模拟 BeanFactory 如何从配置文件中加载 bean 的定义以及依赖关系：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常为BeanDefinitionRegistry的实现类，这里以DeFaultListabeBeanFactory为例</span></span><br><span class="line">BeanDefinitionRegistry beanRegistry = <span class="keyword">new</span> <span class="constructor">DefaultListableBeanFactory()</span>;</span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader实现了BeanDefinitionReader接口，用于解析XML文件</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> <span class="constructor">XmlBeanDefinitionReaderImpl(<span class="params">beanRegistry</span>)</span>;</span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line">beanDefinitionReader.load<span class="constructor">BeanDefinitions(<span class="string">&quot;classpath:spring-bean.xml&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从容器中获取bean实例</span></span><br><span class="line">BeanFactory container = (BeanFactory)beanRegistry;</span><br><span class="line">Business business = (Business)container.get<span class="constructor">Bean(<span class="string">&quot;beanName&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>②、Bean 的实例化阶段</p>
<p>经过第一阶段，所有 bean 定义都通过 BeanDefinition 的方式注册到 BeanDefinitionRegistry 中，当某个请求通过容器的 getBean 方法请求某个对象，或者因为依赖关系容器需要隐式的调用 getBean 时，就会触发第二阶段的活动：容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的 BeanDefinition 所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完毕后，容器会立即将其返回给请求方法使用。</p>
<p>BeanFactory 只是 Spring IoC 容器的一种实现，如果没有特殊指定，它采用采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。而在实际场景下，我们更多的使用另外一种类型的容器：<code>ApplicationContext</code>，它构建在 BeanFactory 之上，属于更高级的容器，除了具有 BeanFactory 的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的 bean，在容器启动时全部完成初始化和依赖注入操作。</p>
<h3 id="1-2、Spring-容器扩展机制"><a href="#1-2、Spring-容器扩展机制" class="headerlink" title="1.2、Spring 容器扩展机制"></a>1.2、Spring 容器扩展机制</h3><p>IoC 容器负责管理容器中所有 bean 的生命周期，而在 bean 生命周期的不同阶段，Spring 提供了不同的扩展点来改变 bean 的命运。在容器的启动阶段，<code>BeanFactoryPostProcessor</code>允许我们在容器实例化相应对象之前，对注册到容器的 BeanDefinition 所保存的信息做一些额外的操作，比如修改 bean 定义的某些属性或者增加其他信息等。</p>
<p>如果要自定义扩展类，通常需要实现<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>接口，与此同时，因为容器中可能有多个 BeanFactoryPostProcessor，可能还需要实现<code>org.springframework.core.Ordered</code>接口，以保证 BeanFactoryPostProcessor 按照顺序执行。Spring 提供了为数不多的 BeanFactoryPostProcessor 实现，我们以<code>PropertyPlaceholderConfigurer</code>来说明其大致的工作流程。</p>
<p>在 Spring 项目的 XML 配置文件中，经常可以看到许多配置项的值使用占位符，而将占位符所代表的值单独配置到独立的 properties 文件，这样可以将散落在不同 XML 文件中的配置集中管理，而且也方便运维根据不同的环境进行配置不同的值。这个非常实用的功能就是由 PropertyPlaceholderConfigurer 负责实现的。</p>
<p>根据前文，当 BeanFactory 在第一阶段加载完所有配置信息时，BeanFactory 中保存的对象的属性还是以占位符方式存在的，比如<code>$&#123;jdbc.mysql.url&#125;</code>。当 PropertyPlaceholderConfigurer 作为 BeanFactoryPostProcessor 被应用时，它会使用 properties 配置文件中的值来替换相应的 BeanDefinition 中占位符所表示的属性值。当需要实例化 bean 时，bean 定义中的属性值就已经被替换成我们配置的值。当然其实现比上面描述的要复杂一些，这里仅说明其大致工作原理，更详细的实现可以参考其源码。</p>
<p>与之相似的，还有<code>BeanPostProcessor</code>，其存在于对象实例化阶段。跟 BeanFactoryPostProcessor 类似，它会处理容器内所有符合条件并且已经实例化后的对象。简单的对比，BeanFactoryPostProcessor 处理 bean 的定义，而 BeanPostProcessor 则处理 bean 完成实例化后的对象。BeanPostProcessor 定义了两个接口：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface BeanPostProcessor &#123;</span><br><span class="line">    <span class="comment">// 前置处理</span></span><br><span class="line">    <span class="built_in">Object</span> <span class="title function_">postProcessBeforeInitialization</span>(<span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName) <span class="keyword">throws</span> BeansException;</span><br><span class="line">    <span class="comment">// 后置处理</span></span><br><span class="line">    <span class="built_in">Object</span> <span class="title function_">postProcessAfterInitialization</span>(<span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName) <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了理解这两个方法执行的时机，简单的了解下 bean 的整个生命周期：</p>
<p>![img](data:image&#x2F;svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="810" height="384"></svg>) <em>Bean 的实例化过程（来自：Spring 揭秘）</em></p>
<p><code>postProcessBeforeInitialization()</code>方法与<code>postProcessAfterInitialization()</code>分别对应图中前置处理和后置处理两个步骤将执行的方法。这两个方法中都传入了 bean 对象实例的引用，为扩展容器的对象实例化过程提供了很大便利，在这儿几乎可以对传入的实例执行任何操作。注解、AOP 等功能的实现均大量使用了<code>BeanPostProcessor</code>，比如有一个自定义注解，你完全可以实现 BeanPostProcessor 的接口，在其中判断 bean 对象的脑袋上是否有该注解，如果有，你可以对这个 bean 实例执行任何操作，想想是不是非常的简单？</p>
<p>再来看一个更常见的例子，在 Spring 中经常能够看到各种各样的 Aware 接口，其作用就是在对象实例化完成以后将 Aware 接口定义中规定的依赖注入到当前实例中。比如最常见的<code>ApplicationContextAware</code>接口，实现了这个接口的类都可以获取到一个 ApplicationContext 对象。当容器中每个对象的实例化过程走到 BeanPostProcessor 前置处理这一步时，容器会检测到之前注册到容器的 ApplicationContextAwareProcessor，然后就会调用其 postProcessBeforeInitialization()方法，检查并设置 Aware 相关依赖。看看代码吧，是不是很简单：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自：org.springframework.context.support.ApplicationContextAwareProcessor</span></span><br><span class="line"><span class="comment">// 其postProcessBeforeInitialization方法调用了invokeAwareInterfaces方法</span></span><br><span class="line"><span class="keyword">private</span> void invoke<span class="constructor">AwareInterfaces(Object <span class="params">bean</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">        ((EnvironmentAware) bean).set<span class="constructor">Environment(<span class="params">this</span>.<span class="params">applicationContext</span>.<span class="params">getEnvironment</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">        ((ApplicationContextAware) bean).set<span class="constructor">ApplicationContext(<span class="params">this</span>.<span class="params">applicationContext</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后总结一下，本小节内容和你一起回顾了 Spring 容器的部分核心内容，限于篇幅不能写更多，但理解这部分内容，足以让您轻松理解 Spring Boot 的启动原理，如果在后续的学习过程中遇到一些晦涩难懂的知识，再回过头来看看 Spring 的核心知识，也许有意想不到的效果。也许 Spring Boot 的中文资料很少，但 Spring 的中文资料和书籍有太多太多，总有东西能给你启发。</p>
<h2 id="二、夯实基础：JavaConfig-与常见-Annotation"><a href="#二、夯实基础：JavaConfig-与常见-Annotation" class="headerlink" title="二、夯实基础：JavaConfig 与常见 Annotation"></a>二、夯实基础：JavaConfig 与常见 Annotation</h2><h3 id="2-1、JavaConfig"><a href="#2-1、JavaConfig" class="headerlink" title="2.1、JavaConfig"></a>2.1、JavaConfig</h3><p>我们知道<code>bean</code>是 Spring IOC 中非常核心的概念，Spring 容器负责 bean 的生命周期的管理。在最初，Spring 使用 XML 配置文件的方式来描述 bean 的定义以及相互间的依赖关系，但随着 Spring 的发展，越来越多的人对这种方式表示不满，因为 Spring 项目的所有业务类均以 bean 的形式配置在 XML 文件中，造成了大量的 XML 文件，使项目变得复杂且难以管理。</p>
<p>后来，基于纯 Java Annotation 依赖注入框架<code>Guice</code>出世，其性能明显优于采用 XML 方式的 Spring，甚至有部分人认为，<code>Guice</code>可以完全取代 Spring（<code>Guice</code>仅是一个轻量级 IOC 框架，取代 Spring 还差的挺远）。正是这样的危机感，促使 Spring 及社区推出并持续完善了<code>JavaConfig</code>子项目，它基于 Java 代码和 Annotation 注解来描述 bean 之间的依赖绑定关系。比如，下面是使用 XML 配置方式来描述 bean 的定义：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attribute">class</span>=<span class="string">&quot;cn.moondev.service.BookServiceImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>而基于 JavaConfig 的配置形式是这样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonBookConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任何标志了@Bean的方法，其返回值将作为一个bean注册到Spring的IOC容器中</span></span><br><span class="line">    <span class="comment">// 方法名默认成为该bean定义的id</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">BookService</span> <span class="title function_">bookService</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个 bean 之间有依赖关系的话，在 XML 配置中应该是这样：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id<span class="operator">=</span><span class="string">&quot;bookService&quot;</span> class<span class="operator">=</span><span class="string">&quot;cn.moondev.service.BookServiceImpl&quot;</span>&gt;</span><br><span class="line">    &lt;property name<span class="operator">=</span><span class="string">&quot;dependencyService&quot;</span> ref<span class="operator">=</span><span class="string">&quot;dependencyService&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id<span class="operator">=</span><span class="string">&quot;otherService&quot;</span> class<span class="operator">=</span><span class="string">&quot;cn.moondev.service.OtherServiceImpl&quot;</span>&gt;</span><br><span class="line">    &lt;property name<span class="operator">=</span><span class="string">&quot;dependencyService&quot;</span> ref<span class="operator">=</span><span class="string">&quot;dependencyService&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id<span class="operator">=</span><span class="string">&quot;dependencyService&quot;</span> class<span class="operator">=</span><span class="string">&quot;DependencyServiceImpl&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>而在 JavaConfig 中则是这样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonBookConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一个bean依赖另一个bean，则直接调用对应JavaConfig类中依赖bean的创建方法即可</span></span><br><span class="line">    <span class="comment">// 这里直接调用dependencyService()</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">BookService</span> <span class="title function_">bookService</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookServiceImpl</span>(<span class="title function_">dependencyService</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">OtherService</span> <span class="title function_">otherService</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OtherServiceImpl</span>(<span class="title function_">dependencyService</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">DependencyService</span> <span class="title function_">dependencyService</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DependencyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能注意到这个示例中，有两个 bean 都依赖于 dependencyService，也就是说当初始化 bookService 时会调用<code>dependencyService()</code>，在初始化 otherService 时也会调用<code>dependencyService()</code>，那么问题来了？这时候 IOC 容器中是有一个 dependencyService 实例还是两个？这个问题留着大家思考吧，这里不再赘述。</p>
<h3 id="2-2、-ComponentScan"><a href="#2-2、-ComponentScan" class="headerlink" title="2.2、@ComponentScan"></a>2.2、@ComponentScan</h3><p><code>@ComponentScan</code>注解对应 XML 配置形式中的&#96;&#96;元素，表示启用组件扫描，Spring 会自动扫描所有通过注解配置的 bean，然后将其注册到 IOC 容器中。我们可以通过<code>basePackages</code>等属性来指定<code>@ComponentScan</code>自动扫描的范围，如果不指定，默认从声明<code>@ComponentScan</code>所在类的<code>package</code>进行扫描。正因为如此，SpringBoot 的启动类都默认在<code>src/main/java</code>下。</p>
<h3 id="2-3、-Import"><a href="#2-3、-Import" class="headerlink" title="2.3、@Import"></a>2.3、@Import</h3><p><code>@Import</code>注解用于导入配置类，举个简单的例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonBookConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">BookService</span> <span class="title function_">bookService</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有另外一个配置类，比如：<code>MoonUserConfiguration</code>，这个配置类中有一个 bean 依赖于<code>MoonBookConfiguration</code>中的 bookService，如何将这两个 bean 组合在一起？借助<code>@Import</code>即可：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="comment">// 可以同时导入多个配置类，比如：@Import(&#123;A.class,B.class&#125;)</span></span><br><span class="line"><span class="variable">@Import</span>(MoonBookConfiguration.class)</span><br><span class="line">public class MoonUserConfiguration &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    public UserService <span class="built_in">userService</span>(BookService bookService) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">BookServiceImpl</span>(bookService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在 4.2 之前，<code>@Import</code>注解只支持导入配置类，但是在 4.2 之后，它支持导入普通类，并将这个类作为一个 bean 的定义注册到 IOC 容器中。</p>
<h3 id="2-4、-Conditional"><a href="#2-4、-Conditional" class="headerlink" title="2.4、@Conditional"></a>2.4、@Conditional</h3><p><code>@Conditional</code>注解表示在满足某种条件后才初始化一个 bean 或者启用某些配置。它一般用在由<code>@Component</code>、<code>@Service</code>、<code>@Configuration</code>等注解标识的类上面，或者由<code>@Bean</code>标记的方法上。如果一个<code>@Configuration</code>类标记了<code>@Conditional</code>，则该类中所有标识了<code>@Bean</code>的方法和<code>@Import</code>注解导入的相关类将遵从这些条件。</p>
<p>在 Spring 里可以很方便的编写你自己的条件类，所要做的就是实现<code>Condition</code>接口，并覆盖它的<code>matches()</code>方法。举个例子，下面的简单条件类表示只有在<code>Classpath</code>里存在<code>JdbcTemplate</code>类时才生效：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">matches</span>(<span class="params">ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        conditionContext.<span class="title function_">getClassLoader</span>().<span class="title function_">loadClass</span>(<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">ClassNotFoundException</span> e) &#123;</span><br><span class="line">            e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你用 Java 来声明 bean 的时候，可以使用这个自定义条件类：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Conditional</span>(JdbcTemplateCondition.class)</span><br><span class="line"><span class="variable">@Service</span></span><br><span class="line">public MyService <span class="built_in">service</span>() &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中只有当<code>JdbcTemplateCondition</code>类的条件成立时才会创建 MyService 这个 bean。也就是说 MyService 这 bean 的创建条件是<code>classpath</code>里面包含<code>JdbcTemplate</code>，否则这个 bean 的声明就会被忽略掉。</p>
<p><code>Spring Boot</code>定义了很多有趣的条件，并把他们运用到了配置类上，这些配置类构成了<code>Spring Boot</code>的自动配置的基础。<code>Spring Boot</code>运用条件化配置的方法是：定义多个特殊的条件化注解，并将它们用到配置类上。下面列出了<code>Spring Boot</code>提供的部分条件化注解：</p>
<table>
<thead>
<tr>
<th>条件化注解</th>
<th>配置生效条件</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnBean</td>
<td>配置了某个特定 bean</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>没有配置特定的 bean</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>Classpath 里有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>Classpath 里没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>给定的 Spring Expression Language 表达式计算结果为 true</td>
</tr>
<tr>
<td>@ConditionalOnJava</td>
<td>Java 的版本匹配特定指或者一个范围值</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>指定的配置属性要有一个明确的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>Classpath 里有指定的资源</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>这是一个 Web 应用程序</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>这不是一个 Web 应用程序</td>
</tr>
</tbody></table>
<h3 id="2-5、-ConfigurationProperties-与-EnableConfigurationProperties"><a href="#2-5、-ConfigurationProperties-与-EnableConfigurationProperties" class="headerlink" title="2.5、@ConfigurationProperties 与@EnableConfigurationProperties"></a>2.5、@ConfigurationProperties 与@EnableConfigurationProperties</h3><p>当某些属性的值需要配置的时候，我们一般会在<code>application.properties</code>文件中新建配置项，然后在 bean 中使用<code>@Value</code>注解来获取配置的值，比如下面配置数据源的代码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdbc config</span></span><br><span class="line">jdbc.<span class="property">mysql</span>.<span class="property">url</span>=<span class="attr">jdbc</span>:<span class="attr">mysql</span>:<span class="comment">//localhost:3306/sampledb</span></span><br><span class="line">jdbc.<span class="property">mysql</span>.<span class="property">username</span>=root</span><br><span class="line">jdbc.<span class="property">mysql</span>.<span class="property">password</span>=<span class="number">123456</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置数据源</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HikariDataSourceConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">&quot;jdbc.mysql.url&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">&quot;jdbc.mysql.username&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> user;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">&quot;jdbc.mysql.password&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">HikariDataSource</span> <span class="title function_">dataSource</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">HikariConfig</span> hikariConfig = <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        hikariConfig.<span class="title function_">setJdbcUrl</span>(url);</span><br><span class="line">        hikariConfig.<span class="title function_">setUsername</span>(user);</span><br><span class="line">        hikariConfig.<span class="title function_">setPassword</span>(password);</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@Value</code>注解注入的属性通常都比较简单，如果同一个配置在多个地方使用，也存在不方便维护的问题（考虑下，如果有几十个地方在使用某个配置，而现在你想改下名字，你改怎么做？）。对于更为复杂的配置，Spring Boot 提供了更优雅的实现方式，那就是<code>@ConfigurationProperties</code>注解。我们可以通过下面的方式来改写上面的代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//  还可以通过@PropertySource(&quot;classpath:jdbc.properties&quot;)来指定配置文件</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">&quot;jdbc.mysql&quot;</span>)</span><br><span class="line"><span class="comment">// 前缀=jdbc.mysql，会在配置文件中寻找jdbc.mysql.*的配置项</span></span><br><span class="line">pulic <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> url;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> username;</span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HikariDataSourceConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AutoWired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">JdbcConfig</span> config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">HikariDataSource</span> <span class="title function_">dataSource</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">HikariConfig</span> hikariConfig = <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">        hikariConfig.<span class="title function_">setJdbcUrl</span>(config.<span class="property">url</span>);</span><br><span class="line">        hikariConfig.<span class="title function_">setUsername</span>(config.<span class="property">username</span>);</span><br><span class="line">        hikariConfig.<span class="title function_">setPassword</span>(config.<span class="property">password</span>);</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@ConfigurationProperties</code>对于更为复杂的配置，处理起来也是得心应手，比如有如下配置文件：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#App</span></span><br><span class="line">app.menus[0].<span class="attribute">title</span>=Home</span><br><span class="line">app.menus[0].<span class="attribute">name</span>=Home</span><br><span class="line">app.menus[0].<span class="attribute">path</span>=/</span><br><span class="line">app.menus[1].<span class="attribute">title</span>=Login</span><br><span class="line">app.menus[1].<span class="attribute">name</span>=Login</span><br><span class="line">app.menus[1].<span class="attribute">path</span>=/login</span><br><span class="line"></span><br><span class="line">app.compiler.<span class="attribute">timeout</span>=5</span><br><span class="line">app.compiler.<span class="attribute">output-folder</span>=/temp/</span><br><span class="line"></span><br><span class="line">app.<span class="attribute">error</span>=/error/</span><br></pre></td></tr></table></figure>

<p>可以定义如下配置类来接收这些属性</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(<span class="string">&quot;app&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> error;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Menu&gt; menus = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Compiler compiler = <span class="keyword">new</span> <span class="type">Compiler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">String</span> name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">String</span> path;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">String</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">String</span> timeout;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">String</span> outputFolder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@EnableConfigurationProperties</code>注解表示对<code>@ConfigurationProperties</code>的内嵌支持，默认会将对应 Properties Class 作为 bean 注入的 IOC 容器中，即在相应的 Properties 类上不用加<code>@Component</code>注解。</p>
<h2 id="三、削铁如泥：SpringFactoriesLoader-详解"><a href="#三、削铁如泥：SpringFactoriesLoader-详解" class="headerlink" title="三、削铁如泥：SpringFactoriesLoader 详解"></a>三、削铁如泥：SpringFactoriesLoader 详解</h2><p>JVM 提供了 3 种类加载器：<code>BootstrapClassLoader</code>、<code>ExtClassLoader</code>、<code>AppClassLoader</code>分别加载 Java 核心类库、扩展类库以及应用的类路径(<code>CLASSPATH</code>)下的类库。JVM 通过双亲委派模型进行类的加载，我们也可以通过继承<code>java.lang.classloader</code>实现自己的类加载器。</p>
<p>何为双亲委派模型？当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的 BootstrapClassLoader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。</p>
<p>采用双亲委派模型的一个好处是保证使用不同类加载器最终得到的都是同一个对象，这样就可以保证 Java 核心库的类型安全，比如，加载位于 rt.jar 包中的<code>java.lang.Object</code>类，不管是哪个加载器加载这个类，最终都是委托给顶层的 BootstrapClassLoader 来加载的，这样就可以保证任何的类加载器最终得到的都是同样一个 Object 对象。查看 ClassLoader 的源码，对双亲委派模型会有更直观的认识：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>, <span class="params">boolean</span> <span class="params">resolve</span>)</span> &#123;</span><br><span class="line">    synchronized (get<span class="constructor">ClassLoadingLock(<span class="params">name</span>)</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先，检查该类是否已经被加载，如果从JVM缓存中找到该类，则直接返回</span></span><br><span class="line">    Class&lt;?&gt; c = find<span class="constructor">LoadedClass(<span class="params">name</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遵循双亲委派的模型，首先会通过递归从父加载器开始找，</span></span><br><span class="line">            <span class="comment">// 直到父类加载器是BootstrapClassLoader为止</span></span><br><span class="line">            <span class="keyword">if</span> (parent != null) &#123;</span><br><span class="line">                c = parent.load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = find<span class="constructor">BootstrapClassOrNull(<span class="params">name</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">            <span class="comment">// 如果还找不到，尝试通过findClass方法去寻找</span></span><br><span class="line">            <span class="comment">// findClass是留给开发者自己实现的，也就是说</span></span><br><span class="line">            <span class="comment">// 自定义类加载器时，重写此方法即可</span></span><br><span class="line">           c = find<span class="constructor">Class(<span class="params">name</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolve<span class="constructor">Class(<span class="params">c</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但双亲委派模型并不能解决所有的类加载器问题，比如，Java 提供了很多服务提供者接口(<code>Service Provider Interface</code>，SPI)，允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JNDI、JAXP 等，这些 SPI 的接口由核心类库提供，却由第三方实现，这样就存在一个问题：SPI 的接口是 Java 核心库的一部分，是由 BootstrapClassLoader 加载的；SPI 实现的 Java 类一般是由 AppClassLoader 来加载的。BootstrapClassLoader 是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给 AppClassLoader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题。</p>
<p>线程上下文类加载器(<code>ContextClassLoader</code>)正好解决了这个问题。从名称上看，可能会误解为它是一种新的类加载器，实际上，它仅仅是 Thread 类的一个变量而已，可以通过<code>setContextClassLoader(ClassLoader cl)</code>和<code>getContextClassLoader()</code>来设置和获取该对象。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是 AppClassLoader。在核心类库使用 SPI 接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。但在 JDBC 中，你可能会看到一种更直接的实现方式，比如，JDBC 驱动管理<code>java.sql.Driver</code>中的<code>loadInitialDrivers()</code>方法中，你可以直接看到 JDK 是如何加载驱动的：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 直接使用AppClassLoader</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Class</span>.</span></span><span class="keyword">for</span><span class="constructor">Name(<span class="params">aDriver</span>, <span class="params">true</span>, ClassLoader.<span class="params">getSystemClassLoader</span>()</span>);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实讲解线程上下文类加载器，最主要是让大家在看到<code>Thread.currentThread().getClassLoader()</code>和<code>Thread.currentThread().getContextClassLoader()</code>时不会一脸懵逼，这两者除了在许多底层框架中取得的 ClassLoader 可能会有所不同外，其他大多数业务场景下都是一样的，大家只要知道它是为了解决什么问题而存在的即可。</p>
<p>类加载器除了加载 class 外，还有一个非常重要功能，就是加载资源，它可以从 jar 包中读取任何资源文件，比如，<code>ClassLoader.getResources(String name)</code>方法就是用于读取 jar 包中的资源文件，其代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Enumeration&lt;URL&gt; get<span class="constructor">Resources(String <span class="params">name</span>)</span> throws IOException &#123;</span><br><span class="line">    Enumeration&lt;URL&gt;<span class="literal">[]</span> tmp = (Enumeration&lt;URL&gt;<span class="literal">[]</span>) <span class="keyword">new</span> Enumeration&lt;?&gt;<span class="literal">[<span class="number">2</span>]</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent != null) &#123;</span><br><span class="line">        tmp<span class="literal">[<span class="number">0</span>]</span> = parent.get<span class="constructor">Resources(<span class="params">name</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp<span class="literal">[<span class="number">0</span>]</span> = get<span class="constructor">BootstrapResources(<span class="params">name</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp<span class="literal">[<span class="number">1</span>]</span> = find<span class="constructor">Resources(<span class="params">name</span>)</span>;</span><br><span class="line">    return <span class="keyword">new</span> CompoundEnumeration&lt;&gt;(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是觉得有点眼熟，不错，它的逻辑其实跟类加载的逻辑是一样的，首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务，直到 BootstrapClassLoader，最后才轮到自己查找。而不同的类加载器负责扫描不同路径下的 jar 包，就如同加载 class 一样，最后会扫描所有的 jar 包，找到符合条件的资源文件。</p>
<p>类加载器的<code>findResources(name)</code>方法会遍历其负责加载的所有 jar 包，找到 jar 包中名称为 name 的资源文件，这里的资源可以是任何文件，甚至是.class 文件，比如下面的示例，用于查找 Array.class 文件：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找Array.class文件</span></span><br><span class="line">public static void main(String<span class="literal">[]</span> args) throws Exception&#123;</span><br><span class="line">    <span class="comment">// Array.class的完整路径</span></span><br><span class="line">    String name = <span class="string">&quot;java/sql/Array.class&quot;</span>;</span><br><span class="line">    Enumeration&lt;URL&gt; urls = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">ContextClassLoader()</span>.get<span class="constructor">Resources(<span class="params">name</span>)</span>;</span><br><span class="line">    <span class="keyword">while</span> (urls.has<span class="constructor">MoreElements()</span>) &#123;</span><br><span class="line">        URL url = urls.next<span class="constructor">Element()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(url.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后可以得到如下结果：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$JAVA_HOME</span><span class="regexp">/jre/</span>lib<span class="regexp">/rt.jar!/</span>java<span class="regexp">/sql/</span>Array.class</span><br></pre></td></tr></table></figure>

<p>根据资源文件的 URL，可以构造相应的文件来读取资源内容。</p>
<p>看到这里，你可能会感到挺奇怪的，你不是要详解<code>SpringFactoriesLoader</code>吗？上来讲了一堆 ClassLoader 是几个意思？看下它的源码你就知道了：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static final String FACTORIES_RESOURCE_LOCATION = <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"><span class="comment">// spring.factories文件的格式为：key=value1,value2,value3</span></span><br><span class="line"><span class="comment">// 从所有的jar包中找到META-INF/spring.factories文件</span></span><br><span class="line"><span class="comment">// 然后从文件中解析出key=factoryClass类名称的所有value值</span></span><br><span class="line">public static List&lt;String&gt; load<span class="constructor">FactoryNames(Class&lt;?&gt; <span class="params">factoryClass</span>, ClassLoader <span class="params">classLoader</span>)</span> &#123;</span><br><span class="line">    String factoryClassName = factoryClass.get<span class="constructor">Name()</span>;</span><br><span class="line">    <span class="comment">// 取得资源文件的URL</span></span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.get<span class="constructor">Resources(FACTORIES_RESOURCE_LOCATION)</span> : <span class="module-access"><span class="module"><span class="identifier">ClassLoader</span>.</span></span>get<span class="constructor">SystemResources(FACTORIES_RESOURCE_LOCATION)</span>);</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">// 遍历所有的URL</span></span><br><span class="line">    <span class="keyword">while</span> (urls.has<span class="constructor">MoreElements()</span>) &#123;</span><br><span class="line">        URL url = urls.next<span class="constructor">Element()</span>;</span><br><span class="line">        <span class="comment">// 根据资源文件URL解析properties文件</span></span><br><span class="line">        Properties properties = <span class="module-access"><span class="module"><span class="identifier">PropertiesLoaderUtils</span>.</span></span>load<span class="constructor">Properties(<span class="params">new</span> UrlResource(<span class="params">url</span>)</span>);</span><br><span class="line">        String factoryClassNames = properties.get<span class="constructor">Property(<span class="params">factoryClassName</span>)</span>;</span><br><span class="line">        <span class="comment">// 组装数据，并返回</span></span><br><span class="line">        result.add<span class="constructor">All(Arrays.<span class="params">asList</span>(StringUtils.<span class="params">commaDelimitedListToStringArray</span>(<span class="params">factoryClassNames</span>)</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了前面关于 ClassLoader 的知识，再来理解这段代码，是不是感觉豁然开朗：从<code>CLASSPATH</code>下的每个 Jar 包中搜寻所有<code>META-INF/spring.factories</code>配置文件，然后将解析 properties 文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去 ClassPath 路径下查找，会扫描所有路径下的 Jar 包，只不过这个文件只会在 Classpath 下的 jar 包中。来简单看下<code>spring.factories</code>文件的内容吧：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories</span></span><br><span class="line"><span class="comment">// EnableAutoConfiguration后文会讲到，它用于开启Spring Boot自动配置功能</span></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span>.EnableAutoConfiguration=\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.admin</span><span class="selector-class">.SpringApplicationAdminJmxAutoConfiguration</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.aop</span><span class="selector-class">.AopAutoConfiguration</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.amqp</span>.RabbitAutoConfiguration\</span><br></pre></td></tr></table></figure>

<p>执行<code>loadFactoryNames(EnableAutoConfiguration.class, classLoader)</code>后，得到对应的一组<code>@Configuration</code>类，<br>我们就可以通过反射实例化这些类然后注入到 IOC 容器中，最后容器里就有了一系列标注了<code>@Configuration</code>的 JavaConfig 形式的配置类。</p>
<p>这就是<code>SpringFactoriesLoader</code>，它本质上属于 Spring 框架私有的一种扩展方案，类似于 SPI，Spring Boot 在 Spring 基础上的很多核心功能都是基于此，希望大家可以理解。</p>
<h2 id="四、另一件武器：Spring-容器的事件监听机制"><a href="#四、另一件武器：Spring-容器的事件监听机制" class="headerlink" title="四、另一件武器：Spring 容器的事件监听机制"></a>四、另一件武器：Spring 容器的事件监听机制</h2><p>过去，事件监听机制多用于图形界面编程，比如：<strong>点击</strong>按钮、在文本框<strong>输入</strong>内容等操作被称为事件，而当事件触发时，应用程序作出一定的响应则表示应用监听了这个事件，而在服务器端，事件的监听机制更多的用于异步通知以及监控和异常处理。Java 提供了实现事件监听机制的两个基础类：自定义事件类型扩展自<code>java.util.EventObject</code>、事件的监听器扩展自<code>java.util.EventListener</code>。来看一个简单的实例：简单的监控一个方法的耗时。</p>
<p>首先定义事件类型，通常的做法是扩展 EventObject，随着事件的发生，相应的状态通常都封装在此类中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MethodMonitorEvent</span> <span class="keyword">extends</span> <span class="title">EventObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间戳，用于记录方法开始执行的时间</span></span><br><span class="line">    public long timestamp;</span><br><span class="line"></span><br><span class="line">    public <span class="type">MethodMonitorEvent</span>(<span class="type">Object</span> source) &#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件发布之后，相应的监听器即可对该类型的事件进行处理，我们可以在方法开始执行之前发布一个 begin 事件，在方法执行结束之后发布一个 end 事件，相应地，事件监听器需要提供方法对这两种情况下接收到的事件进行处理：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、定义事件监听接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">MethodMonitorEventListener</span> <span class="title">extends</span> <span class="title">EventListener</span> &#123;</span><br><span class="line">    <span class="comment">// 处理方法执行之前发布的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodBegin</span>(<span class="params">MethodMonitorEvent <span class="keyword">event</span></span>)</span>;</span><br><span class="line">    <span class="comment">// 处理方法结束时发布的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodEnd</span>(<span class="params">MethodMonitorEvent <span class="keyword">event</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、事件监听接口的实现：如何处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AbstractMethodMonitorEventListener</span> <span class="title">implements</span> <span class="title">MethodMonitorEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodBegin</span>(<span class="params">MethodMonitorEvent <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录方法开始执行时的时间</span></span><br><span class="line">        <span class="keyword">event</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodEnd</span>(<span class="params">MethodMonitorEvent <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算方法耗时</span></span><br><span class="line">        <span class="built_in">long</span> duration = System.currentTimeMillis() - <span class="keyword">event</span>.timestamp;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;耗时：&quot;</span> + duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件监听器接口针对不同的事件发布实际提供相应的处理方法定义，最重要的是，其方法只接收 MethodMonitorEvent 参数，说明这个监听器类只负责监听器对应的事件并进行处理。有了事件和监听器，剩下的就是发布事件，然后让相应的监听器监听并处理。通常情况，我们会有一个事件发布者，它本身作为事件源，在合适的时机，将相应的事件发布给对应的事件监听器：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodMonitorEventPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">List</span>&lt;<span class="title class_">MethodMonitorEventListener</span>&gt; listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="title class_">MethodMonitorEventListener</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">methodMonitor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">MethodMonitorEvent</span> eventObject = <span class="keyword">new</span> <span class="title class_">MethodMonitorEvent</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="title function_">publishEvent</span>(<span class="string">&quot;begin&quot;</span>,eventObject);</span><br><span class="line">        <span class="comment">// 模拟方法执行：休眠5秒钟</span></span><br><span class="line">        <span class="title class_">TimeUnit</span>.<span class="property">SECONDS</span>.<span class="title function_">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="title function_">publishEvent</span>(<span class="string">&quot;end&quot;</span>,eventObject);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">publishEvent</span>(<span class="params"><span class="built_in">String</span> status,MethodMonitorEvent event</span>) &#123;</span><br><span class="line">        <span class="comment">// 避免在事件处理期间，监听器被移除，这里为了安全做一个复制操作</span></span><br><span class="line">        <span class="title class_">List</span>&lt;<span class="title class_">MethodMonitorEventListener</span>&gt; copyListeners = ➥ <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="title class_">MethodMonitorEventListener</span>&gt;(listeners);</span><br><span class="line">        <span class="keyword">for</span> (<span class="title class_">MethodMonitorEventListener</span> listener : copyListeners) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;begin&quot;</span>.<span class="title function_">equals</span>(status)) &#123;</span><br><span class="line">                listener.<span class="title function_">onMethodBegin</span>(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                listener.<span class="title function_">onMethodEnd</span>(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">MethodMonitorEventPublisher</span> publisher = <span class="keyword">new</span> <span class="title class_">MethodMonitorEventPublisher</span>();</span><br><span class="line">        publisher.<span class="title function_">addEventListener</span>(<span class="keyword">new</span> <span class="title class_">AbstractMethodMonitorEventListener</span>());</span><br><span class="line">        publisher.<span class="title function_">methodMonitor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">addEventListener</span>(<span class="params">MethodMonitorEventListener listener</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">removeEventListener</span>(<span class="params">MethodMonitorEventListener listener</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">removeAllListeners</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对于事件发布者（事件源）通常需要关注两点：</p>
<ol>
<li>在合适的时机发布事件。此例中的 methodMonitor()方法是事件发布的源头，其在方法执行之前和结束之后两个时间点发布 MethodMonitorEvent 事件，每个时间点发布的事件都会传给相应的监听器进行处理。在具体实现时需要注意的是，事件发布是顺序执行，为了不影响处理性能，事件监听器的处理逻辑应尽量简单。</li>
<li>事件监听器的管理。publisher 类中提供了事件监听器的注册与移除方法，这样客户端可以根据实际情况决定是否需要注册新的监听器或者移除某个监听器。如果这里没有提供 remove 方法，那么注册的监听器示例将一直被 MethodMonitorEventPublisher 引用，即使已经废弃不用了，也依然在发布者的监听器列表中，这会导致隐性的内存泄漏。</li>
</ol>
<h4 id="Spring-容器内的事件监听机制"><a href="#Spring-容器内的事件监听机制" class="headerlink" title="Spring 容器内的事件监听机制"></a>Spring 容器内的事件监听机制</h4><p>Spring 的 ApplicationContext 容器内部中的所有事件类型均继承自<code>org.springframework.context.AppliationEvent</code>，容器中的所有监听器都实现<code>org.springframework.context.ApplicationListener</code>接口，并且以 bean 的形式注册在容器中。一旦在容器内发布 ApplicationEvent 及其子类型的事件，注册到容器的 ApplicationListener 就会对这些事件进行处理。</p>
<p>你应该已经猜到是怎么回事了。</p>
<p>ApplicationEvent 继承自 EventObject，Spring 提供了一些默认的实现，比如：<code>ContextClosedEvent</code>表示容器在即将关闭时发布的事件类型，<code>ContextRefreshedEvent</code>表示容器在初始化或者刷新的时候发布的事件类型……</p>
<p>容器内部使用 ApplicationListener 作为事件监听器接口定义，它继承自 EventListener。ApplicationContext 容器在启动时，会自动识别并加载 EventListener 类型的 bean，一旦容器内有事件发布，将通知这些注册到容器的 EventListener。</p>
<p>ApplicationContext 接口继承了 ApplicationEventPublisher 接口，该接口提供了<code>void publishEvent(ApplicationEvent event)</code>方法定义，不难看出，ApplicationContext 容器担当的就是事件发布者的角色。如果有兴趣可以查看<code>AbstractApplicationContext.publishEvent(ApplicationEvent event)</code>方法的源码：ApplicationContext 将事件的发布以及监听器的管理工作委托给<code>ApplicationEventMulticaster</code>接口的实现类。在容器启动时，会检查容器内是否存在名为 applicationEventMulticaster 的 ApplicationEventMulticaster 对象实例。如果有就使用其提供的实现，没有就默认初始化一个 SimpleApplicationEventMulticaster 作为实现。</p>
<p>最后，如果我们业务需要在容器内部发布事件，只需要为其注入 ApplicationEventPublisher 依赖即可：实现 ApplicationEventPublisherAware 接口或者 ApplicationContextAware 接口(Aware 接口相关内容请回顾上文)。</p>
<h2 id="五、出神入化：揭秘自动配置原理"><a href="#五、出神入化：揭秘自动配置原理" class="headerlink" title="五、出神入化：揭秘自动配置原理"></a>五、出神入化：揭秘自动配置原理</h2><p>典型的 Spring Boot 应用的启动类一般均位于<code>src/main/java</code>根路径下，比如<code>MoonApplication</code>类：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">SpringApplication</span>.<span class="title function_">run</span>(<span class="title class_">MoonApplication</span>.<span class="property">class</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>@SpringBootApplication</code>开启组件扫描和自动配置，而<code>SpringApplication.run</code>则负责启动引导应用程序。<code>@SpringBootApplication</code>是一个复合<code>Annotation</code>，它将三个有用的注解组合在一起：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Inherited</span></span><br><span class="line"><span class="variable">@SpringBootConfiguration</span></span><br><span class="line"><span class="variable">@EnableAutoConfiguration</span></span><br><span class="line"><span class="variable">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">        <span class="variable">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">        <span class="variable">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public <span class="variable">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@SpringBootConfiguration</code>就是<code>@Configuration</code>，它是 Spring 框架的注解，标明该类是一个<code>JavaConfig</code>配置类。而<code>@ComponentScan</code>启用组件扫描，前文已经详细讲解过，这里着重关注<code>@EnableAutoConfiguration</code>。</p>
<p><code>@EnableAutoConfiguration</code>注解表示开启 Spring Boot 自动配置功能，Spring Boot 会根据应用的依赖、自定义的 bean、classpath 下有没有某个类 等等因素来猜测你需要的 bean，然后注册到 IOC 容器中。那<code>@EnableAutoConfiguration</code>是如何推算出你的需求？首先看下它的定义：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Inherited</span></span><br><span class="line"><span class="variable">@AutoConfigurationPackage</span></span><br><span class="line"><span class="variable">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line">public <span class="variable">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你的关注点应该在<code>@Import(EnableAutoConfigurationImportSelector.class)</code>上了，前文说过，<code>@Import</code>注解用于导入类，并将这个类作为一个 bean 的定义注册到容器中，这里它将把<code>EnableAutoConfigurationImportSelector</code>作为 bean 注入到容器中，而这个类会将所有符合条件的@Configuration 配置都加载到容器中，看看它的代码：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span>[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="comment">// 省略了大部分代码，保留一句核心代码</span></span><br><span class="line">    <span class="comment">// 注意：SpringBoot最近版本中，这句代码被封装在一个单独的方法中</span></span><br><span class="line">    <span class="comment">// SpringFactoriesLoader相关知识请参考前文</span></span><br><span class="line">    List&lt;<span class="keyword">String</span>&gt; factories = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="keyword">String</span>&gt;(<span class="keyword">new</span> <span class="type">LinkedHashSet</span>&lt;<span class="keyword">String</span>&gt;(</span><br><span class="line">        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, <span class="built_in">this</span>.beanClassLoader)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类会扫描所有的 jar 包，将所有符合条件的@Configuration 配置类注入的容器中，何为符合条件，看看<code>META-INF/spring.factories</code>的文件内容：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories</span></span><br><span class="line"><span class="comment">// 配置的key = EnableAutoConfiguration，与代码中一致</span></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span>.EnableAutoConfiguration=\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.jdbc</span><span class="selector-class">.DataSourceAutoConfiguration</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.aop</span><span class="selector-class">.AopAutoConfiguration</span>,\</span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.amqp</span>.RabbitAutoConfiguration\</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>以<code>DataSourceAutoConfiguration</code>为例，看看 Spring Boot 是如何自动配置的：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ConditionalOnClass</span>(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span><br><span class="line"><span class="variable">@EnableConfigurationProperties</span>(DataSourceProperties.class)</span><br><span class="line"><span class="variable">@Import</span>(&#123; Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class &#125;)</span><br><span class="line">public class DataSourceAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别说一说：</p>
<ul>
<li><code>@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</code>：当 Classpath 中存在 DataSource 或者 EmbeddedDatabaseType 类时才启用这个配置，否则这个配置将被忽略。</li>
<li><code>@EnableConfigurationProperties(DataSourceProperties.class)</code>：将 DataSource 的默认配置类注入到 IOC 容器中，DataSourceproperties 定义为：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供对datasource配置信息的支持，所有的配置前缀为：spring.datasource</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = <span class="string">&quot;spring.datasource&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span>  &#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;testdb&quot;</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Import(&#123; Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class &#125;)</code>：导入其他额外的配置，就以<code>DataSourcePoolMetadataProvidersConfiguration</code>为例吧。</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line">public class DataSourcePoolMetadataProvidersConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Configuration</span></span><br><span class="line">    <span class="variable">@ConditionalOnClass</span>(org.apache.tomcat.jdbc.pool.DataSource.class)</span><br><span class="line">    static class TomcatDataSourcePoolMetadataProviderConfiguration &#123;</span><br><span class="line">        <span class="variable">@Bean</span></span><br><span class="line">        public DataSourcePoolMetadataProvider <span class="built_in">tomcatPoolDataSourceMetadataProvider</span>() &#123;</span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DataSourcePoolMetadataProvidersConfiguration 是数据库连接池提供者的一个配置类，即 Classpath 中存在<code>org.apache.tomcat.jdbc.pool.DataSource.class</code>，则使用 tomcat-jdbc 连接池，如果 Classpath 中存在<code>HikariDataSource.class</code>则使用 Hikari 连接池。</p>
<p>这里仅描述了 DataSourceAutoConfiguration 的冰山一角，但足以说明 Spring Boot 如何利用条件话配置来实现自动配置的。回顾一下，<code>@EnableAutoConfiguration</code>中导入了 EnableAutoConfigurationImportSelector 类，而这个类的<code>selectImports()</code>通过 SpringFactoriesLoader 得到了大量的配置类，而每一个配置类则根据条件化配置来做出决策，以实现自动配置。</p>
<p>整个流程很清晰，但漏了一个大问题：<code>EnableAutoConfigurationImportSelector.selectImports()</code>是何时执行的？其实这个方法会在容器启动过程中执行：<code>AbstractApplicationContext.refresh()</code>，更多的细节在下一小节中说明。</p>
<h2 id="六、启动引导：Spring-Boot-应用启动的秘密"><a href="#六、启动引导：Spring-Boot-应用启动的秘密" class="headerlink" title="六、启动引导：Spring Boot 应用启动的秘密"></a>六、启动引导：Spring Boot 应用启动的秘密</h2><h3 id="6-1-SpringApplication-初始化"><a href="#6-1-SpringApplication-初始化" class="headerlink" title="6.1 SpringApplication 初始化"></a>6.1 SpringApplication 初始化</h3><p>SpringBoot 整个启动流程分为两个步骤：初始化一个 SpringApplication 对象、执行该对象的 run 方法。看下 SpringApplication 的初始化流程，SpringApplication 的构造方法中调用 initialize(Object[] sources)方法，其代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void initialize(Object<span class="literal">[]</span> sources) &#123;</span><br><span class="line">     <span class="keyword">if</span> (sources != null<span class="operator"> &amp;&amp; </span>sources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         this.sources.add<span class="constructor">All(Arrays.<span class="params">asList</span>(<span class="params">sources</span>)</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 判断是否是Web项目</span></span><br><span class="line">     this.webEnvironment = deduce<span class="constructor">WebEnvironment()</span>;</span><br><span class="line">     set<span class="constructor">Initializers((Collection)</span> get<span class="constructor">SpringFactoriesInstances(ApplicationContextInitializer.<span class="params">class</span>)</span>);</span><br><span class="line">     set<span class="constructor">Listeners((Collection)</span> get<span class="constructor">SpringFactoriesInstances(ApplicationListener.<span class="params">class</span>)</span>);</span><br><span class="line">     <span class="comment">// 找到入口类</span></span><br><span class="line">     this.mainApplicationClass = deduce<span class="constructor">MainApplicationClass()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化流程中最重要的就是通过 SpringFactoriesLoader 找到<code>spring.factories</code>文件中配置的<code>ApplicationContextInitializer</code>和<code>ApplicationListener</code>两个接口的实现类名称，以便后期构造相应的实例。<code>ApplicationContextInitializer</code>的主要目的是在<code>ConfigurableApplicationContext</code>做 refresh 之前，对 ConfigurableApplicationContext 实例做进一步的设置或处理。ConfigurableApplicationContext 继承自 ApplicationContext，其主要提供了对 ApplicationContext 进行设置的能力。</p>
<p>实现一个 ApplicationContextInitializer 非常简单，因为它只有一个方法，但大多数情况下我们没有必要自定义一个 ApplicationContextInitializer，即便是 Spring Boot 框架，它默认也只是注册了两个实现，毕竟 Spring 的容器已经非常成熟和稳定，你没有必要来改变它。</p>
<p>而<code>ApplicationListener</code>的目的就没什么好说的了，它是 Spring 框架对 Java 事件监听机制的一种框架实现，具体内容在前文 Spring 事件监听机制这个小节有详细讲解。这里主要说说，如果你想为 Spring Boot 应用添加监听器，该如何实现？</p>
<p>Spring Boot 提供两种方式来添加自定义监听器：</p>
<ul>
<li>通过<code>SpringApplication.addListeners(ApplicationListener... listeners)</code>或者<code>SpringApplication.setListeners(Collection&gt; listeners)</code>两个方法来添加一个或者多个自定义监听器</li>
<li>既然 SpringApplication 的初始化流程中已经从<code>spring.factories</code>中获取到<code>ApplicationListener</code>的实现类，那么我们直接在自己的 jar 包的<code>META-INF/spring.factories</code>文件中新增配置即可：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.context</span>.ApplicationListener=\</span><br><span class="line">cn<span class="selector-class">.moondev</span><span class="selector-class">.listeners</span>.xxxxListener\</span><br></pre></td></tr></table></figure>

<p>关于 SpringApplication 的初始化，我们就说这么多。</p>
<h3 id="6-2-Spring-Boot-启动流程"><a href="#6-2-Spring-Boot-启动流程" class="headerlink" title="6.2 Spring Boot 启动流程"></a>6.2 Spring Boot 启动流程</h3><p>Spring Boot 应用的整个启动流程都封装在 SpringApplication.run 方法中，其整个流程真的是太长太长了，但本质上就是在 Spring 容器启动的基础上做了大量的扩展，按照这个思路来看看源码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> <span class="constructor">StopWatch()</span>;</span><br><span class="line">        stopWatch.start<span class="literal">()</span>;</span><br><span class="line">        ConfigurableApplicationContext context = null;</span><br><span class="line">        FailureAnalyzers analyzers = null;</span><br><span class="line">        configure<span class="constructor">HeadlessProperty()</span>;</span><br><span class="line">        <span class="comment">// ①</span></span><br><span class="line">        SpringApplicationRunListeners listeners = get<span class="constructor">RunListeners(<span class="params">args</span>)</span>;</span><br><span class="line">        listeners.starting<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ②</span></span><br><span class="line">            ApplicationArguments applicationArguments = <span class="keyword">new</span> <span class="constructor">DefaultApplicationArguments(<span class="params">args</span>)</span>;</span><br><span class="line">            ConfigurableEnvironment environment = prepare<span class="constructor">Environment(<span class="params">listeners</span>,<span class="params">applicationArguments</span>)</span>;</span><br><span class="line">            <span class="comment">// ③</span></span><br><span class="line">            Banner printedBanner = print<span class="constructor">Banner(<span class="params">environment</span>)</span>;</span><br><span class="line">            <span class="comment">// ④</span></span><br><span class="line">            context = create<span class="constructor">ApplicationContext()</span>;</span><br><span class="line">            <span class="comment">// ⑤</span></span><br><span class="line">            analyzers = <span class="keyword">new</span> <span class="constructor">FailureAnalyzers(<span class="params">context</span>)</span>;</span><br><span class="line">            <span class="comment">// ⑥</span></span><br><span class="line">            prepare<span class="constructor">Context(<span class="params">context</span>, <span class="params">environment</span>, <span class="params">listeners</span>, <span class="params">applicationArguments</span>,<span class="params">printedBanner</span>)</span>;</span><br><span class="line">            <span class="comment">// ⑦</span></span><br><span class="line">            refresh<span class="constructor">Context(<span class="params">context</span>)</span>;</span><br><span class="line">            <span class="comment">// ⑧</span></span><br><span class="line">            after<span class="constructor">Refresh(<span class="params">context</span>, <span class="params">applicationArguments</span>)</span>;</span><br><span class="line">            <span class="comment">// ⑨</span></span><br><span class="line">            listeners.finished(context, null);</span><br><span class="line">            stopWatch.stop<span class="literal">()</span>;</span><br><span class="line">            return context;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            handle<span class="constructor">RunFailure(<span class="params">context</span>, <span class="params">listeners</span>, <span class="params">analyzers</span>, <span class="params">ex</span>)</span>;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="params">ex</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>① 通过 SpringFactoriesLoader 查找并加载所有的<code>SpringApplicationRunListeners</code>，通过调用 starting()方法通知所有的 SpringApplicationRunListeners：应用开始启动了。SpringApplicationRunListeners 其本质上就是一个事件发布者，它在 SpringBoot 应用启动的不同时间点发布不同应用事件类型(ApplicationEvent)，如果有哪些事件监听者(ApplicationListener)对这些事件感兴趣，则可以接收并且处理。还记得初始化流程中，SpringApplication 加载了一系列 ApplicationListener 吗？这个启动流程中没有发现有发布事件的代码，其实都已经在 SpringApplicationRunListeners 这儿实现了。</p>
<p>简单的分析一下其实现流程，首先看下 SpringApplicationRunListener 的源码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行run方法时立即调用此方法，可以用户非常早期的初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">starting</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Environment准备好后，并且ApplicationContext创建之前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span>(<span class="params">ConfigurableEnvironment environment</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApplicationContext创建好后立即调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span>(<span class="params">ConfigurableApplicationContext context</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApplicationContext加载完成，在refresh之前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span>(<span class="params">ConfigurableApplicationContext context</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当run方法结束之前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span>(<span class="params">ConfigurableApplicationContext context, Throwable exception</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringApplicationRunListener 只有一个实现类：<code>EventPublishingRunListener</code>。① 处的代码只会获取到一个 EventPublishingRunListener 的实例，我们来看看 starting()方法的内容：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 发布一个ApplicationStartedEvent</span></span><br><span class="line">    <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationStartedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺着这个逻辑，你可以在 ② 处的<code>prepareEnvironment()</code>方法的源码中找到<code>listeners.environmentPrepared(environment);</code>即 SpringApplicationRunListener 接口的第二个方法，那不出你所料，<code>environmentPrepared()</code>又发布了另外一个事件<code>ApplicationEnvironmentPreparedEvent</code>。接下来会发生什么，就不用我多说了吧。</p>
<p>② 创建并配置当前应用将要使用的<code>Environment</code>，Environment 用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，开发经验丰富的同学对这两个东西一定不会陌生：不同的环境(eg：生产环境、预发布环境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当 Environment 准备好后，在整个应用的任何时候，都可以从 Environment 中获取资源。</p>
<p>总结起来，② 处的两句代码，主要完成以下几件事：</p>
<ul>
<li>判断 Environment 是否存在，不存在就创建（如果是 web 项目就创建<code>StandardServletEnvironment</code>，否则创建<code>StandardEnvironment</code>）</li>
<li>配置 Environment：配置 profile 以及 properties</li>
<li>调用 SpringApplicationRunListener 的<code>environmentPrepared()</code>方法，通知事件监听者：应用的 Environment 已经准备好</li>
</ul>
<p>③、SpringBoot 应用在启动时会输出这样的东西：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ |<span class="string"> &#x27;_ </span>|<span class="string"> &#x27;_</span>|<span class="string"> </span>|<span class="string"> &#x27;_ \/ _` </span>|<span class="string"> \ \ \ \</span></span><br><span class="line"><span class="string"> \\/  ___)</span>|<span class="string"> </span>|<span class="string">_)</span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>||<span class="string"> (_</span>|<span class="string"> </span>|<span class="string">  ) ) ) )</span></span><br><span class="line"><span class="string">  &#x27;  </span>|<span class="string">____</span>|<span class="string"> .__</span>|<span class="string">_</span>|<span class="string"> </span>|<span class="string">_</span>|<span class="string">_</span>|<span class="string"> </span>|<span class="string">_\__, </span>|<span class="string"> / / / /</span></span><br><span class="line"><span class="string"> =========</span>|<span class="string">_</span>|<span class="string">==============</span>|<span class="string">___/=/_/_/_/</span></span><br><span class="line"><span class="string"> :: Spring Boot ::        (v1.5.6.RELEASE)</span></span><br></pre></td></tr></table></figure>

<p>如果想把这个东西改成自己的涂鸦，你可以研究以下 Banner 的实现，这个任务就留给你们吧。</p>
<p>④、根据是否是 web 项目，来创建不同的 ApplicationContext 容器。</p>
<p>⑤、创建一系列<code>FailureAnalyzer</code>，创建流程依然是通过 SpringFactoriesLoader 获取到所有实现 FailureAnalyzer 接口的 class，然后在创建对应的实例。FailureAnalyzer 用于分析故障并提供相关诊断信息。</p>
<p>⑥、初始化 ApplicationContext，主要完成以下工作：</p>
<ul>
<li>将准备好的 Environment 设置给 ApplicationContext</li>
<li>遍历调用所有的 ApplicationContextInitializer 的<code>initialize()</code>方法来对已经创建好的 ApplicationContext 进行进一步的处理</li>
<li>调用 SpringApplicationRunListener 的<code>contextPrepared()</code>方法，通知所有的监听者：ApplicationContext 已经准备完毕</li>
<li>将所有的 bean 加载到容器中</li>
<li>调用 SpringApplicationRunListener 的<code>contextLoaded()</code>方法，通知所有的监听者：ApplicationContext 已经装载完毕</li>
</ul>
<p>⑦、调用 ApplicationContext 的<code>refresh()</code>方法，完成 IoC 容器可用的最后一道工序。从名字上理解为刷新容器，那何为刷新？就是插手容器的启动，联系一下第一小节的内容。那如何刷新呢？且看下面代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘自refresh()方法中一句代码</span></span><br><span class="line">invoke<span class="constructor">BeanFactoryPostProcessors(<span class="params">beanFactory</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>看看这个方法的实现：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void invoke<span class="constructor">BeanFactoryPostProcessors(ConfigurableListableBeanFactory <span class="params">beanFactory</span>)</span> &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">PostProcessorRegistrationDelegate</span>.</span></span>invoke<span class="constructor">BeanFactoryPostProcessors(<span class="params">beanFactory</span>, <span class="params">getBeanFactoryPostProcessors</span>()</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取到所有的<code>BeanFactoryPostProcessor</code>来对容器做一些额外的操作。BeanFactoryPostProcessor 允许我们在容器实例化相应对象之前，对注册到容器的 BeanDefinition 所保存的信息做一些额外的操作。这里的 getBeanFactoryPostProcessors()方法可以获取到 3 个 Processor：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConfigurationWarningsApplicationContextInitializer<span class="symbol">$Co</span>nfigurationWarningsPostProcessor</span><br><span class="line">SharedMetadataReaderFactoryContextInitializer<span class="symbol">$Cac</span>hingMetadataReaderFactoryPostProcessor</span><br><span class="line">ConfigFileApplicationListener<span class="symbol">$PropertySourceOrderi</span>ngPostProcessor</span><br></pre></td></tr></table></figure>

<p>不是有那么多 BeanFactoryPostProcessor 的实现类，为什么这儿只有这 3 个？因为在初始化流程获取到的各种 ApplicationContextInitializer 和 ApplicationListener 中，只有上文 3 个做了类似于如下操作：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">initialize</span>(<span class="params">ConfigurableApplicationContext context</span>) &#123;</span><br><span class="line">    context.<span class="title function_">addBeanFactoryPostProcessor</span>(<span class="keyword">new</span> <span class="title class_">ConfigurationWarningsPostProcessor</span>(<span class="title function_">getChecks</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你就可以进入到<code>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()</code>方法了，这个方法除了会遍历上面的 3 个 BeanFactoryPostProcessor 处理外，还会获取类型为<code>BeanDefinitionRegistryPostProcessor</code>的 bean：<code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code>，对应的 Class 为<code>ConfigurationClassPostProcessor</code>。<code>ConfigurationClassPostProcessor</code>用于解析处理各种注解，包括：@Configuration、@ComponentScan、@Import、@PropertySource、@ImportResource、@Bean。当处理<code>@import</code>注解的时候，就会调用&lt;自动配置&gt;这一小节中的<code>EnableAutoConfigurationImportSelector.selectImports()</code>来完成自动配置功能。其他的这里不再多讲，如果你有兴趣，可以查阅参考资料 6。</p>
<p>⑧、查找当前 context 中是否注册有 CommandLineRunner 和 ApplicationRunner，如果有则遍历执行它们。</p>
<p>⑨、执行所有 SpringApplicationRunListener 的 finished()方法。</p>
<p>这就是 Spring Boot 的整个启动流程，其核心就是在 Spring 容器初始化并启动的基础上加入各种扩展点，这些扩展点包括：ApplicationContextInitializer、ApplicationListener 以及各种 BeanFactoryPostProcessor 等等。你对整个流程的细节不必太过关注，甚至没弄明白也没有关系，你只要理解这些扩展点是在何时如何工作的，能让它们为你所用即可。</p>
<p>整个启动流程确实非常复杂，可以查询参考资料中的部分章节和内容，对照着源码，多看看，我想最终你都能弄清楚的。言而总之，Spring 才是核心，理解清楚 Spring 容器的启动流程，那 Spring Boot 启动流程就不在话下了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://union-click.jd.com/jdc?d=4jESQ9">王福强 著；SpringBoot 揭秘：快速构建微服务体系; 机械工业出版社, 2016</a><br>[2] <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://union-click.jd.com/jdc?d=yzfgeF">王福强 著；Spring 揭秘; 人民邮件出版社, 2009</a><br>[3] <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://union-click.jd.com/jdc?d=AQ6oHO">Craig Walls 著；丁雪丰 译；Spring Boot 实战；中国工信出版集团 人民邮电出版社，2016</a><br>[4] <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://www.ibm.com/developerworks/cn/java/j-lo-classloader/">深入探讨 Java 类加载器</a> : <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://www.ibm.com/developerworks/cn/java/j-lo-classloader/">www.ibm.com/developerwo…</a><br>[5] <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/liaokailin/article/details/49559951">spring boot 实战：自动配置原理分析</a> : <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/liaokailin/article/details/49559951">blog.csdn.net&#x2F;liaokailin&#x2F;…</a><br>[6]<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/liaokailin/article/details/49107209">spring boot实战：spring boot bean加载源码分析</a>： <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/liaokailin/article/details/49107209">blog.csdn.net&#x2F;liaokailin&#x2F;…</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/dbf521/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/dbf521/" class="post-title-link" itemprop="url">SpringBoot 基本原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-12 07:01:26" itemprop="dateCreated datePublished" datetime="2020-08-12T07:01:26+08:00">2020-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 18:54:25" itemprop="dateModified" datetime="2022-09-23T18:54:25+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">框架</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/SpringBoot/" itemprop="url" rel="index"><span itemprop="name">SpringBoot</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/Java/%E6%A1%86%E6%9E%B6/SpringBoot/SpringBoot%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">SpringBoot综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SpringBoot-基本原理"><a href="#SpringBoot-基本原理" class="headerlink" title="SpringBoot 基本原理"></a>SpringBoot 基本原理</h1><p>SpringBoot 为我们做的自动配置，确实方便快捷，但一直搞不明白它的内部启动原理，这次就来一步步解开 SpringBoot 的神秘面纱，让它不再神秘。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6430208-ebcb376f96103703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，<strong>Annotation 定义（@SpringBootApplication）和类定义（SpringApplication.run）</strong>最为耀眼，所以要揭开 SpringBoot 的神秘面纱，我们要从这两位开始就可以了。</p>
<h2 id="SpringBootApplication-背后的秘密"><a href="#SpringBootApplication-背后的秘密" class="headerlink" title="SpringBootApplication 背后的秘密"></a>SpringBootApplication 背后的秘密</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span>            <span class="comment">// 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>  <span class="comment">// 注解的生命周期，保留到class文件中（三个生命周期）</span></span><br><span class="line"><span class="meta">@Documented</span>                          <span class="comment">// 表明这个注解应该被javadoc记录</span></span><br><span class="line"><span class="meta">@Inherited</span>                           <span class="comment">// 子类可以继承该注解</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span>             <span class="comment">// 继承了Configuration，表示当前是注解类</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span>             <span class="comment">// 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;    // 扫描路径设置（具体使用待确认）</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然定义使用了多个 Annotation 进行了原信息标注，但实际上重要的只有三个 Annotation：</p>
<p><strong>@Configuration</strong>（@SpringBootConfiguration 点开查看发现里面还是应用了@Configuration）<br><strong>@EnableAutoConfiguration<br>@ComponentScan</strong><br>所以，如果我们使用如下的 SpringBoot 启动类，整个 SpringBoot 应用依然可以与之前的启动类功能对等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次写这 3 个比较累，所以写一个@SpringBootApplication 方便点。接下来分别介绍这 3 个 Annotation。</p>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>这里的@Configuration 对我们来说不陌生，<strong>它就是 JavaConfig 形式的 Spring Ioc 容器的配置类使用的那个@Configuration</strong>，SpringBoot 社区推荐使用基于 JavaConfig 的配置形式，所以，这里的启动类标注了@Configuration 之后，本身其实也是一个 IoC 容器的配置类。<br>举几个简单例子回顾下，XML 跟 config 配置方式的区别：</p>
<p>表达形式层面<br>基于 XML 配置的方式是这样：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而基于 JavaConfig 的配置方式是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockConfiguration</span>&#123;</span><br><span class="line">    <span class="comment">//bean定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>任何一个标注了@Configuration 的 Java 类定义都是一个 JavaConfig 配置类。</strong></p>
<p>注册 bean 定义层面<br>基于 XML 的配置形式是这样：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;mockService&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;..MockServiceImpl&quot;</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>而基于 JavaConfig 的配置形式是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockConfiguration</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MockService <span class="title function_">mockService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MockServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>任何一个标注了@Bean 的方法，其返回值将作为一个 bean 定义注册到 Spring 的 IoC 容器，方法名将默认成该 bean 定义的 id。</strong></p>
<p>表达依赖注入关系层面<br>为了表达 bean 与 bean 之间的依赖关系，在 XML 形式中一般是这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;mockService&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;..MockServiceImpl&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span> =<span class="string">&quot;dependencyService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dependencyService&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dependencyService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;DependencyServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>而基于 JavaConfig 的配置形式是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockConfiguration</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MockService <span class="title function_">mockService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MockServiceImpl</span>(dependencyService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DependencyService <span class="title function_">dependencyService</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DependencyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果一个 bean 的定义依赖其他 bean,则直接调用对应的 JavaConfig 类中依赖 bean 的创建方法就可以了。</strong></p>
<h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p><strong>@ComponentScan 这个注解在 Spring 中很重要，它对应 XML 配置中的元素，@ComponentScan 的功能其实就是自动扫描并加载符合条件的组件（比如@Component 和@Repository 等）或者 bean 定义，最终将这些 bean 定义加载到 IoC 容器中。</strong></p>
<p>我们可以通过 basePackages 等属性来细粒度的定制@ComponentScan 自动扫描的范围，如果不指定，则默认 Spring 框架实现会从声明@ComponentScan 所在类的 package 进行扫描。</p>
<blockquote>
<p>注：所以 SpringBoot 的启动类最好是放在 root package 下，因为默认不指定 basePackages。</p>
</blockquote>
<h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p>个人感觉**@EnableAutoConfiguration 这个 Annotation 最为重要**，所以放在最后来解读，大家是否还记得 Spring 框架提供的各种名字为@Enable 开头的 Annotation 定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport 等，@EnableAutoConfiguration 的理念和做事方式其实一脉相承，简单概括一下就是，借助@Import 的支持，收集和注册特定场景相关的 bean 定义。</p>
<p><strong>@EnableScheduling</strong>是通过@Import 将 Spring 调度框架相关的 bean 定义都加载到 IoC 容器。<br><strong>@EnableMBeanExport</strong>是通过@Import 将 JMX 相关的 bean 定义加载到 IoC 容器。<br>而**@EnableAutoConfiguration**也是借助@Import 的帮助，将所有符合自动配置条件的 bean 定义加载到 IoC 容器，仅此而已！</p>
<p>@EnableAutoConfiguration 作为一个复合 Annotation,其自身定义关键信息如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(<span class="string">&quot;deprecation&quot;</span>)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(EnableAutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个比较重要的注解：</p>
<p><strong>@AutoConfigurationPackage：自动配置包</strong></p>
<p><strong>@Import: 导入自动配置的组件</strong></p>
<h4 id="AutoConfigurationPackage-注解："><a href="#AutoConfigurationPackage-注解：" class="headerlink" title="AutoConfigurationPackage 注解："></a>AutoConfigurationPackage 注解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Registrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span><br><span class="line"><span class="params">                BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">            register(registry, <span class="keyword">new</span> <span class="title class_">PackageImport</span>(metadata).getPackageName());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>它其实是注册了一个 Bean 的定义。</p>
<p>new PackageImport(metadata).getPackageName()，它其实返回了当前主程序类的 同级以及子级 的包组件。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6430208-439283a70a24c7a0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/281/format/webp" alt="img"></p>
<p>以上图为例，DemoApplication 是和 demo 包同级，但是 demo2 这个类是 DemoApplication 的父级，和 example 包同级</p>
<p>也就是说，DemoApplication 启动加载的 Bean 中，并不会加载 demo2，这也就是为什么，我们要把 DemoApplication 放在项目的最高级中。</p>
<h4 id="Import-AutoConfigurationImportSelector-class-注解："><a href="#Import-AutoConfigurationImportSelector-class-注解：" class="headerlink" title="Import(AutoConfigurationImportSelector.class)注解："></a>Import(AutoConfigurationImportSelector.class)注解：</h4><p><img src="https://upload-images.jianshu.io/upload_images/6430208-1c448a69c41dc35c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/877/format/webp" alt="img"></p>
<p>可以从图中看出 AutoConfigurationImportSelector 继承了 DeferredImportSelector 继承了 ImportSelector</p>
<p>ImportSelector 有一个方法为：selectImports。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    public <span class="built_in">String</span>[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125;</span><br><span class="line">        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">                .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                attributes);</span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">        <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(configurations);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到第九行，它其实是去加载 public static final String FACTORIES_RESOURCE_LOCATION &#x3D; “META-INF&#x2F;spring.factories”;外部文件。这个外部文件，有很多自动配置的类。如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6430208-250f3320c15e5c99.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>image</p>
<p>其中，最关键的要属**@Import(EnableAutoConfigurationImportSelector.class)<strong>，借助</strong>EnableAutoConfigurationImportSelector<strong>，</strong>@EnableAutoConfiguration<strong>可以帮助 SpringBoot 应用将所有符合条件的</strong>@Configuration**配置都加载到当前 SpringBoot 创建并使用的 IoC 容器。就像一只“八爪鱼”一样。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6430208-6f3a835755ee7710.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<h3 id="自动配置幕后英雄：SpringFactoriesLoader-详解"><a href="#自动配置幕后英雄：SpringFactoriesLoader-详解" class="headerlink" title="自动配置幕后英雄：SpringFactoriesLoader 详解"></a>自动配置幕后英雄：SpringFactoriesLoader 详解</h3><p>借助于 Spring 框架原有的一个工具类：SpringFactoriesLoader 的支持，@EnableAutoConfiguration 可以智能的自动配置功效才得以大功告成！</p>
<p>SpringFactoriesLoader 属于 Spring 框架私有的一种扩展方案，其主要功能就是从指定的配置文件 META-INF&#x2F;spring.factories 加载配置。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringFactoriesLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_ invoke__">loadFactories</span>(Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">static</span> List&lt;String&gt; <span class="title function_ invoke__">loadFactoryNames</span>(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配合**@EnableAutoConfiguration<strong>使用的话，它更多是提供一种配置查找的功能支持，即根据@EnableAutoConfiguration 的完整类名 org.springframework.boot.autoconfigure.EnableAutoConfiguration 作为查找的 Key,获取对应的一组</strong>@Configuration**类</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6430208-fcdfcb56828a015a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>上图就是从 SpringBoot 的 autoconfigure 依赖包中的 META-INF&#x2F;spring.factories 配置文件中摘录的一段内容，可以很好地说明问题。</p>
<p>所以，@EnableAutoConfiguration 自动配置的魔法骑士就变成了：<strong>从 classpath 中搜寻所有的 META-INF&#x2F;spring.factories 配置文件，并将其中 org.springframework.boot.autoconfigure.EnableutoConfiguration 对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration 的 JavaConfig 形式的 IoC 容器配置类，然后汇总为一个并加载到 IoC 容器。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6430208-10850d62d44c95ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/822/format/webp" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/943650ab7dfd">一文搞懂 springboot 启动原理</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/86db92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/86db92/" class="post-title-link" itemprop="url">领域驱动设计简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-10 10:59:18" itemprop="dateCreated datePublished" datetime="2020-08-10T10:59:18+08:00">2020-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 18:54:25" itemprop="dateModified" datetime="2022-09-23T18:54:25+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/DDD/" itemprop="url" rel="index"><span itemprop="name">DDD</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="领域驱动设计简介"><a href="#领域驱动设计简介" class="headerlink" title="领域驱动设计简介"></a>领域驱动设计简介</h1><h2 id="DDD-简介"><a href="#DDD-简介" class="headerlink" title="DDD 简介"></a>DDD 简介</h2><h3 id="软件架构模式的演进"><a href="#软件架构模式的演进" class="headerlink" title="软件架构模式的演进"></a>软件架构模式的演进</h3><p><strong>第一阶段是单机架构：</strong>采用面向过程的设计方法，系统包括客户端 UI 层和数据库两层，采用 C&#x2F;S 架构模式，整个系统围绕数据库驱动设计和开发，并且总是从设计数据库和字段开始。</p>
<p><strong>第二阶段是集中式架构：</strong>采用面向对象的设计方法，系统包括业务接入层、业务逻辑层和数据库层，采用经典的三层架构，也有部分应用采用传统的 SOA 架构。这种架构容易使系统变得臃肿，可扩展性和弹性伸缩性差。</p>
<p><strong>第三阶段是分布式微服务架构：</strong>随着微服务架构理念的提出，集中式架构正向分布式微服务架构演进。微服务架构可以很好地实现应用之间的解耦，解决单体应用扩展性和弹性伸缩能力不足的问题。</p>
<p>在单机和集中式架构时代，系统分析、设计和开发往往是独立、分阶段割裂进行的。</p>
<h3 id="什么是-DDD"><a href="#什么是-DDD" class="headerlink" title="什么是 DDD"></a>什么是 DDD</h3><p>DDD 是一种处理高度复杂领域的<strong>设计思想</strong>，它试图分离技术实现的复杂性，并<strong>围绕业务概念构建领域模型来控制业务的复杂性</strong>，以解决软件难以理解，难以演进的问题。DDD 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。DDD 分为两个思维层面：</p>
<ul>
<li>战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的上下文边界，上下文边界可以作为微服务设计的参考边界。</li>
<li>战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。</li>
</ul>
<h3 id="DDD-与微服务的关系"><a href="#DDD-与微服务的关系" class="headerlink" title="DDD 与微服务的关系"></a>DDD 与微服务的关系</h3><p><strong>DDD 是一种架构设计方法，微服务是一种架构风格</strong>。两者都是为了拆解业务复杂度：合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。</p>
<p>DDD 主要关注：<strong>从业务领域视角划分领域边界</strong>，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。</p>
<p>微服务主要关注：<strong>运行时的进程间通信、容错和故障隔离</strong>，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。</p>
<h2 id="DDD-核心概念"><a href="#DDD-核心概念" class="headerlink" title="DDD 核心概念"></a>DDD 核心概念</h2><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200719231154.png" alt="img"></p>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><ul>
<li><strong>领域</strong>：领域具体指一种特定的<strong>范围</strong>。领域是用来限定业务边界的，那么就会有大小之分，领域越大，业务范围就越大，反之则相反。</li>
<li><strong>子域</strong>：领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。</li>
<li><strong>核心域</strong>：决定产品和公司核心竞争力的子域是核心域。</li>
<li><strong>通用域</strong>：同时被多个子域使用的通用功能子域是通用域。</li>
<li><strong>支撑域</strong>：还有一种功能子域是必需的，但既非核心域也非通用域，它就是支撑域。</li>
</ul>
<blockquote>
<p><strong>领域的核心思想就是将问题域逐级细分，来降低业务理解和系统实现的复杂度</strong>。通过领域细分，逐步缩小微服务需要解决的问题域，构建合适的领域模型，而领域模型映射成系统就是微服务了。</p>
<p>核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属性和重要性，从而公司可对不同子域采取不同的资源投入和建设策略，其关注度也会不一样。</p>
</blockquote>
<h3 id="通用语言和上下文边界"><a href="#通用语言和上下文边界" class="headerlink" title="通用语言和上下文边界"></a>通用语言和上下文边界</h3><p><strong>通用语言</strong>：通过团队交流达成共识性的，能够简单、清晰、准确描述业务涵义和规则的语言。</p>
<p><strong>上下文边界</strong>：限界就是领域的边界，而上下文则是语义环境。通过领域的上下文边界，我们就可以在统一的领域边界内用统一的语言进行交流。综合一下，上下文边界的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。</p>
<h3 id="实体和值对象"><a href="#实体和值对象" class="headerlink" title="实体和值对象"></a>实体和值对象</h3><p>实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合。你可以这么理解，实体和值对象是组成领域模型的基础单元。</p>
<p>本质上，实体是看得到、摸得着的实实在在的业务对象，实体具有业务属性、业务行为和业务逻辑。而值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征。</p>
<h3 id="聚合和聚合跟"><a href="#聚合和聚合跟" class="headerlink" title="聚合和聚合跟"></a>聚合和聚合跟</h3><p>领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。</p>
<p>聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。</p>
<p>聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200719152031.png" alt="img"></p>
<h4 id="聚合设计步骤"><a href="#聚合设计步骤" class="headerlink" title="聚合设计步骤"></a>聚合设计步骤</h4><ul>
<li>第 1 步：采用事件风暴，根据业务行为，梳理出所有的实体和值对象。</li>
<li>第 2 步：从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体<br>是否是聚合根，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一 ID？<br>是否可以创建或修改其它对象？是否有专门的模块来管这个实体。</li>
<li>第 3 步：根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值<br>对象。</li>
<li>第 4 步：在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。</li>
<li>第 5 步：多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。</li>
</ul>
<h4 id="聚合设计原则"><a href="#聚合设计原则" class="headerlink" title="聚合设计原则"></a>聚合设计原则</h4><ul>
<li>在一致性边界内建模真正的不变条件。</li>
<li>设计小聚合。</li>
<li>通过唯一标识引用其它聚合。</li>
<li>在边界之外使用最终一致性。</li>
<li>通过应用层实现跨聚合的服务调用。</li>
</ul>
<h2 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h2><h3 id="DDD-架构"><a href="#DDD-架构" class="headerlink" title="DDD 架构"></a>DDD 架构</h3><p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200719223353.png" alt="img"></p>
<p>三层架构向 DDD 分层架构演进，主要发生在业务逻辑层和数据访问层。</p>
<p>DDD 分层架构包含用户接口层、应用层、领域层和基础层。通过这些层次划分，我们可以明确微服务各层的职能，划定各领域对象的边界，确定各领域对象的协作方式。</p>
<h3 id="整洁架构"><a href="#整洁架构" class="headerlink" title="整洁架构"></a>整洁架构</h3><p>在整洁架构里，同心圆代表应用软件的不同部分，从里到外依次是领域模型、领域服务、应用服务和最外围的容易变化的内容，比如用户界面和基础设施。</p>
<p>整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200719223906.png" alt="img"></p>
<h3 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h3><p>六边形架构的核心理念是：应用是通过端口与外部进行交互的。我想这也是微服务架构下 API 网关盛行的主要原因吧。</p>
<p>也就是说，在下图的六边形架构中，红圈内的核心业务逻辑（应用程序和领域模型）与外部资源（包括 APP、Web 应用以及数据库资源等）完全隔离，仅通过适配器进行交互。它解决了业务逻辑与用户界面的代码交错问题，很好地实现了前后端分离。六边形架构各层的依赖关系与整洁架构一样，都是由外向内依赖。</p>
<p>六边形架构将系统分为内六边形和外六边形两层，这两层的职能划分如下：</p>
<p>红圈内的六边形实现应用的核心业务逻辑；</p>
<p>外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以 API 主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。</p>
<h3 id="三种架构对比"><a href="#三种架构对比" class="headerlink" title="三种架构对比"></a>三种架构对比</h3><p>这三种架构模型的设计思想正是微服务架构高内聚低耦合原则的完美体现。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200719224313.png" alt="img"></p>
<h4 id="架构模型和中台、微服务的联系"><a href="#架构模型和中台、微服务的联系" class="headerlink" title="架构模型和中台、微服务的联系"></a>架构模型和中台、微服务的联系</h4><p>中台本质上是领域的子域，它可能是核心域，也可能是通用域或支撑域。通常大家认为阿里的中台对应 DDD 的通用域，将通用的公共能力沉淀为中台，对外提供通用共享服务。</p>
<p>DDD、中台、微服务这三者之间似乎没什么关联，实际上它们的关系是非常紧密的，组合在一起可以作为<br>一个理论体系用于你的中台和微服务设计。</p>
<h4 id="中台建设要聚焦领域模型"><a href="#中台建设要聚焦领域模型" class="headerlink" title="中台建设要聚焦领域模型"></a>中台建设要聚焦领域模型</h4><p>中台需要站在全企业的高度考虑能力的共享和复用。</p>
<p>中台设计时，我们需要建立中台内所有限界上下文的领域模型，DDD 建模过程中会考虑架构演进和功能的重新组合。领域模型建立的过程会对业务和应用进行清晰的逻辑和物理边界（微服务）划分。领域模型的结果会影响到后续的系统模型、架构模型和代码模型，最终影响到微服务的拆分和项目落地。</p>
<h4 id="微服务要有合理的架构分层"><a href="#微服务要有合理的架构分层" class="headerlink" title="微服务要有合理的架构分层"></a>微服务要有合理的架构分层</h4><p>微服务设计要有分层的设计思想，让各层各司其职，建立松耦合的层间关系。</p>
<p>不要把与领域无关的逻辑放在领域层实现，保证领域层的纯洁和领域逻辑的稳定，避免污染领域模型。也不要把领域模型的业务逻辑放在应用层，这样会导致应用层过于庞大，最终领域模型会失焦。</p>
<h4 id="应用和资源的解耦与适配"><a href="#应用和资源的解耦与适配" class="headerlink" title="应用和资源的解耦与适配"></a>应用和资源的解耦与适配</h4><p>传统以数据为中心的设计模式，应用会对数据库、缓存、文件系统等基础资源产生严重依赖。</p>
<p>正是由于它们之间的这种强依赖的关系，我们一旦更换基础资源就会对应用产生很大的影响，因此需要为应用和资源解耦。</p>
<h2 id="中台战略"><a href="#中台战略" class="headerlink" title="中台战略"></a>中台战略</h2><h3 id="平台不是中台"><a href="#平台不是中台" class="headerlink" title="平台不是中台"></a>平台不是中台</h3><p>中台源于平台，但它的战略高度要比平台高很多。</p>
<p><strong>平台只是将部分通用的公共能力独立为共享平台</strong>。虽然可以通过 API 或者数据对外提供公共共享服务，解决系统重复建设的问题，但这类平台并没有和企业内的其它平台或应用，实现页面、业务流程和数据从前端到后端的全面融合，并且<strong>没有将核心业务服务链路作为一个整体方案考虑，各平台仍然是分离且独立的</strong>。</p>
<p>简单的理解就是把传统的前后台体系中的后台进行了细分。阿里巴巴提出了<strong>大中台小前台</strong>的战略。就是强化业务和技术中台，把前端的应用变得更小更灵活。当中台越强大，能力就越强，越能更好的快速响应前台的业务需求。打个比喻，就是土壤越肥沃，越适合生长不同的生物，打造好的生态系统。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200716194609.png" alt="img"></p>
<h3 id="什么是中台"><a href="#什么是中台" class="headerlink" title="什么是中台"></a>什么是中台</h3><p>中台是一个基础的理念和架构，我们要把所有的基础服务用中台的思路建设，进行联通，共同支持上端的业务。业务中台更多的是支持在线业务，数据中台提供了基础数据处理能力和很多的数据产品给所有业务方去用。业务中台、数据中台、算法中台等等一起提供对上层业务的支撑。</p>
<p>中台的关键词：<strong>共享、联通、融合和创新</strong>。联通是前台以及中台之间的联通，融合是前台流程和数据的融合，并以共享的方式支持前端一线业务的发展和创新。其中最关键的是快速响应能力和企业级的无缝联通和融合能力，尤其是对于跨业经营的超大型企业来说至关重要。</p>
<h3 id="数字化转型中台"><a href="#数字化转型中台" class="headerlink" title="数字化转型中台"></a>数字化转型中台</h3><h3 id="前中后台协同"><a href="#前中后台协同" class="headerlink" title="前中后台协同"></a>前中后台协同</h3><h4 id="前台"><a href="#前台" class="headerlink" title="前台"></a>前台</h4><p>在前台设计中我们可以借鉴微前端的设计思想，在企业内不仅实现前端解耦和复用，还可以根据核心链路和业务流程，通过对微前端页面的动态组合和流程编排，实现前台业务的融合。</p>
<p>前端页面可以很自然地融合到不同的终端和渠道应用核心业务链路中，实现前端页面、流程和功能复用。</p>
<h4 id="中台"><a href="#中台" class="headerlink" title="中台"></a>中台</h4><p>业务中台的建设可采用领域驱动设计方法，通过领域建模，将可复用的公共能力从各个单体剥离，沉淀并组合，采用微服务架构模式，建设成为可共享的通用能力中台。</p>
<p>同样的，我们可以将核心能力用微服务架构模式，建设成为可面向不同渠道和场景的可复用的核心能力中台。 业务中台向前台、第三方和其它中台提供 API 服务，实现通用能力和核心能力的复用。</p>
<p>数据中台的主要目标是打通数据孤岛，实现业务融合和创新，包括三大主要职能：</p>
<ul>
<li>一是完成企业全域数据的采集与存储，实现各不同业务类别中台数据的汇总和集中管理。</li>
<li>二是按照标准的数据规范或数据模型，将数据按照不同主题域或场景进行加工和处理，形成面向不同主题和场景的数据应用，比如客户视图、代理人视图、渠道视图、机构视图等不同数据体系。</li>
<li>三是建立业务需求驱动的数据体系，基于各个维度的数据，深度萃取数据价值，支持业务和商业模式的创新。</li>
</ul>
<p>相应的，数据中台的建设就可分为三步走：</p>
<ul>
<li>第一步实现各中台业务数据的汇集，解决数据孤岛和初级数据共享问题。</li>
<li>第二步实现企业级实时或非实时全维度数据的深度融合、加工和共享。</li>
<li>第三步萃取数据价值，支持业务创新，加速从数据转换为业务价值的过程。</li>
</ul>
<h4 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h4><p>前台主要面向客户以及终端销售者，实现营销推广以及交易转化；中台主要面向运营人员，完成运营支撑；后台主要面向后台管理人员，实现流程审核、内部管理以及后勤支撑，比如采购、人力、财务和 OA 等系统。</p>
<h3 id="DDD、中台和微服务的协作"><a href="#DDD、中台和微服务的协作" class="headerlink" title="DDD、中台和微服务的协作"></a>DDD、中台和微服务的协作</h3><p>传统企业可以将需要共享的公共能力进行领域建模，建设可共享的通用中台。除此之外，传统企业还会将核心能力进行领域建模，建设面向不同渠道的可复用的核心中台。</p>
<h3 id="如何构建中台"><a href="#如何构建中台" class="headerlink" title="如何构建中台"></a>如何构建中台</h3><h4 id="自顶向下策略"><a href="#自顶向下策略" class="headerlink" title="自顶向下策略"></a>自顶向下策略</h4><p>自顶向下的策略适用于全新的应用系统建设，或旧系统推倒重建的情况。这种策略是先做顶层设计，从最高领域逐级分解为中台，分别建立领域模型，根据业务属性分为通用中台或核心中台。领域建模过程主要基于业务现状，暂时不考虑系统现状。</p>
<h4 id="自顶向下策略-1"><a href="#自顶向下策略-1" class="headerlink" title="自顶向下策略"></a>自顶向下策略</h4><p>自底向上策略适用于遗留系统业务模型的演进式重构。这种策略是基于业务和系统现状完成领域建模。首先分别完成系统所在业务域的领域建模；然后对齐业务域，找出具有同类或相似业务功能的领域模型，对比分析领域模型的差异，重组领域对象，重构领域模型。这个过程会沉淀公共和复用的业务能力，会将分散的业务模型整合。</p>
<h4 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h4><p>第一步：锁定系统所在业务域，构建领域模型。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200720063540.png" alt="img"></p>
<p>第二步：对齐业务域，构建中台业务模型。</p>
<p>第三步：中台归类，根据领域模型设计微服务。</p>
<h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>逻辑边界：微服务内聚合之间的边界是逻辑边界。它是一个虚拟的边界，强调业务的内聚，可根据需要变成物理边界，也就是说聚合也可以独立为微服务。</p>
<p>物理边界：微服务之间的边界是物理边界。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等。</p>
<p>代码边界：不同层或者聚合之间代码目录的边界是代码边界。它强调的是代码之间的隔离，方便架构演进时代码的重组。</p>
<p>通过以上边界，我们可以让业务能力高内聚、代码松耦合，且清晰的边界，可以快速实现微服务代码的拆分和组合，轻松实现微服务架构演进。但有一点一定要格外注意，边界清晰的微服务，不是大单体向小单体的演进。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100037301">DDD 实战课</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://dunwu.github.io/blog/pages/000a7b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/avatar.gif">
      <meta itemprop="name" content="钝悟 ◾ Dunwu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dunwu Blog">
      <meta itemprop="description" content="钝悟的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Dunwu Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blog/pages/000a7b/" class="post-title-link" itemprop="url">系统架构面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-10 10:59:18" itemprop="dateCreated datePublished" datetime="2020-08-10T10:59:18+08:00">2020-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-23 18:54:25" itemprop="dateModified" datetime="2022-09-23T18:54:25+08:00">2022-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">设计</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E8%AE%BE%E8%AE%A1/%E6%9E%B6%E6%9E%84/%E7%BB%BC%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">综合</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>957</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="系统架构面试"><a href="#系统架构面试" class="headerlink" title="系统架构面试"></a>系统架构面试</h1><h2 id="如何设计一个秒杀系统？"><a href="#如何设计一个秒杀系统？" class="headerlink" title="如何设计一个秒杀系统？"></a>如何设计一个秒杀系统？</h2><h3 id="秒杀系统的挑战"><a href="#秒杀系统的挑战" class="headerlink" title="秒杀系统的挑战"></a>秒杀系统的挑战</h3><p>秒杀的核心问题就是<strong>极高并发处理</strong>，由于系统要在瞬时承受平时数十倍甚至上百倍的流量，这往往超出系统上限，因此处理秒杀的<strong>核心思路是限流和缓存</strong>。</p>
<h3 id="秒杀系统的解决思路"><a href="#秒杀系统的解决思路" class="headerlink" title="秒杀系统的解决思路"></a>秒杀系统的解决思路</h3><ul>
<li>系统上有拦截流量：尽可能在上游拦截和限制请求，限制流入后端的量，保证后端系统正常。 因为无论多少人参与秒杀，实际成交往往是有限的，而且远小于参加秒杀的人数，因此可以通过前端系统进行拦截，限制最终流入系统的请求数量，来保证系统正常进行。</li>
<li>充分利用缓存：这是一个典型的读多写少的应用场景（一趟火车其实只有 2000 张票，200w 个人来买，最多 2000 个人下单成功，其他人都是查询库存，写比例只有 0.1%，读比例占 99.9%），非常适合使用缓存。</li>
</ul>
<h3 id="秒杀系统的解决方案"><a href="#秒杀系统的解决方案" class="headerlink" title="秒杀系统的解决方案"></a>秒杀系统的解决方案</h3><p>秒杀系统具体方案如下：</p>
<p><strong>（1）浏览器、客户端拦截重复请求</strong></p>
<ul>
<li>用户点击查询或购买按钮后，禁用按钮，避免用户重复提交请求。</li>
<li>JS 代码中限制用户在限定时间内只允许提交一次请求</li>
</ul>
<p>基于此，大部分流量已被拦截。</p>
<p><strong>（2）应用层拦截请求</strong></p>
<p>浏览器、客户端拦截重复请求只能应付通过浏览器访问的用户。如果有人通过程序发送 http 请求，则无法拦截。针对这种情况的方案是：</p>
<p>以页面缓存的方式，针对短时间内的同一个访问源（如同一个 IP、同一个 Session、同一个用户 ID 多次发送 HTTP 请求）或同样的查询请求（如大量请求都是查询某类商品的库存），都返回相同的展示页面。</p>
<p>如此限流，又有大部分的流量被拦截</p>
<p>（3）服务层请求拦截与数据缓存</p>
<p>加入有黑客，控制了 10w 台肉鸡（并且假设买票不需要实名认证），前面的的限制都不起作用了。这时应该怎么办？</p>
<ul>
<li><p>读请求（查库存） - 对于读请求，直接使用缓存即可，一般缓存服务器单机处理每秒 10w 个请求应该没什么问题。</p>
</li>
<li><p>写请求（下单） - 由于服务层清楚的知道库存数量，所以完全可以根据库存数量进行限流。具体来说，就是把所有下单请求都丢该消息队列中，每次只取有限的写请求去数据层处理。当这些写请求处理完，更新一下缓存中的库存数，再去取下一批写请求，如果库存数不够，则消息队列的写请求全部返回”已售罄”的结果。</p>
</li>
</ul>
<blockquote>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/54895548/answer/146924420">如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/54895548/answer/259218876">如何设计秒杀系统？ - 网易云的回答 - 知乎</a></li>
</ul>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/54895548/answer/146924420">如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/54895548/answer/259218876">如何设计秒杀系统？ - 网易云的回答 - 知乎</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/blog/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/37/">37</a><a class="extend next" rel="next" href="/blog/page/17/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">钝悟 ◾ Dunwu</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">2.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">42:59</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>




  <script src="/blog/js/third-party/pace.js"></script>

  




<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"dunwu","repo":"blog","client_id":"c45bc13ca1d3d3aa4836","client_secret":"1907a9f0c22087badad3938e1d7dcba9078f88ac","admin_user":"dunwu","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"101260af3d3408182ad1866f50eccae2"}</script>
<script src="/blog/js/third-party/comments/gitalk.js"></script>

</body>
</html>
